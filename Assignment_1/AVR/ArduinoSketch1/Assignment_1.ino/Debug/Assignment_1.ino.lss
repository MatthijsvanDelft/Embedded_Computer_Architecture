
Assignment_1.ino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000186  00800100  00000930  000009c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000930  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a6  00800286  00800286  00000b4a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b4a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000b7c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000250  00000000  00000000  00000bbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000723c  00000000  00000000  00000e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016ad  00000000  00000000  00008048  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014cd  00000000  00000000  000096f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000074c  00000000  00000000  0000abc4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f62  00000000  00000000  0000b310  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000293e  00000000  00000000  0000d272  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  0000fbb0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 c4 03 	jmp	0x788	; 0x788 <__vector_16>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 7a 02 	jmp	0x4f4	; 0x4f4 <__vector_18>
  4c:	0c 94 ac 02 	jmp	0x558	; 0x558 <__vector_19>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
  68:	dc 02       	muls	r29, r28

0000006a <__ctors_end>:
  6a:	11 24       	eor	r1, r1
  6c:	1f be       	out	0x3f, r1	; 63
  6e:	cf ef       	ldi	r28, 0xFF	; 255
  70:	d8 e0       	ldi	r29, 0x08	; 8
  72:	de bf       	out	0x3e, r29	; 62
  74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
  76:	12 e0       	ldi	r17, 0x02	; 2
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	e0 e3       	ldi	r30, 0x30	; 48
  7e:	f9 e0       	ldi	r31, 0x09	; 9
  80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
  82:	05 90       	lpm	r0, Z+
  84:	0d 92       	st	X+, r0
  86:	a6 38       	cpi	r26, 0x86	; 134
  88:	b1 07       	cpc	r27, r17
  8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
  8c:	23 e0       	ldi	r18, 0x03	; 3
  8e:	a6 e8       	ldi	r26, 0x86	; 134
  90:	b2 e0       	ldi	r27, 0x02	; 2
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	ac 32       	cpi	r26, 0x2C	; 44
  98:	b2 07       	cpc	r27, r18
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	c5 e3       	ldi	r28, 0x35	; 53
  a0:	d0 e0       	ldi	r29, 0x00	; 0
  a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
  a4:	21 97       	sbiw	r28, 0x01	; 1
  a6:	fe 01       	movw	r30, r28
  a8:	0e 94 90 04 	call	0x920	; 0x920 <__tablejump2__>
  ac:	c4 33       	cpi	r28, 0x34	; 52
  ae:	d1 07       	cpc	r29, r17
  b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
  b2:	0e 94 0a 03 	call	0x614	; 0x614 <main>
  b6:	0c 94 96 04 	jmp	0x92c	; 0x92c <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
  be:	26 e0       	ldi	r18, 0x06	; 6
  c0:	40 e8       	ldi	r20, 0x80	; 128
  c2:	55 e2       	ldi	r21, 0x25	; 37
  c4:	60 e0       	ldi	r22, 0x00	; 0
  c6:	70 e0       	ldi	r23, 0x00	; 0
  c8:	86 e8       	ldi	r24, 0x86	; 134
  ca:	92 e0       	ldi	r25, 0x02	; 2
  cc:	0c 94 15 02 	jmp	0x42a	; 0x42a <_ZN14HardwareSerial5beginEmh>

000000d0 <loop>:
  // put your setup code here, to run once:
  // initialize serial:
  Serial.begin(9600);
}

void loop() {
  d0:	2f 92       	push	r2
  d2:	3f 92       	push	r3
  d4:	4f 92       	push	r4
  d6:	5f 92       	push	r5
  d8:	6f 92       	push	r6
  da:	7f 92       	push	r7
  dc:	8f 92       	push	r8
  de:	9f 92       	push	r9
  e0:	af 92       	push	r10
  e2:	bf 92       	push	r11
  e4:	cf 92       	push	r12
  e6:	df 92       	push	r13
  e8:	ef 92       	push	r14
  ea:	ff 92       	push	r15
  ec:	0f 93       	push	r16
  ee:	1f 93       	push	r17
  f0:	cf 93       	push	r28
  f2:	df 93       	push	r29
  f4:	cd b7       	in	r28, 0x3d	; 61
  f6:	de b7       	in	r29, 0x3e	; 62
  f8:	c8 5a       	subi	r28, 0xA8	; 168
  fa:	d2 40       	sbci	r29, 0x02	; 2
  fc:	0f b6       	in	r0, 0x3f	; 63
  fe:	f8 94       	cli
 100:	de bf       	out	0x3e, r29	; 62
 102:	0f be       	out	0x3f, r0	; 63
 104:	cd bf       	out	0x3d, r28	; 61
  // put your main code here, to run repeatedly:
   
    int32_t matrixR[NR_MATRIX_ELEMENTS] = {0};
 106:	fe 01       	movw	r30, r28
 108:	31 96       	adiw	r30, 0x01	; 1
 10a:	84 ea       	ldi	r24, 0xA4	; 164
 10c:	92 e0       	ldi	r25, 0x02	; 2
 10e:	df 01       	movw	r26, r30
 110:	9c 01       	movw	r18, r24
 112:	1d 92       	st	X+, r1
 114:	21 50       	subi	r18, 0x01	; 1
 116:	30 40       	sbci	r19, 0x00	; 0
 118:	e1 f7       	brne	.-8      	; 0x112 <loop+0x42>
  
    register uint8_t e = NR_MATRIX_ELEMENTS;
    register uint8_t k = 0; 
  
    /*Start timer*/
    unsigned long startTime = micros();
 11a:	0e 94 0e 04 	call	0x81c	; 0x81c <micros>
 11e:	cb 55       	subi	r28, 0x5B	; 91
 120:	dd 4f       	sbci	r29, 0xFD	; 253
 122:	68 83       	st	Y, r22
 124:	79 83       	std	Y+1, r23	; 0x01
 126:	8a 83       	std	Y+2, r24	; 0x02
 128:	9b 83       	std	Y+3, r25	; 0x03
 12a:	c5 5a       	subi	r28, 0xA5	; 165
 12c:	d2 40       	sbci	r29, 0x02	; 2
 12e:	2e 01       	movw	r4, r28
 130:	3f e5       	ldi	r19, 0x5F	; 95
 132:	43 1a       	sub	r4, r19
 134:	3d ef       	ldi	r19, 0xFD	; 253
 136:	53 0a       	sbc	r5, r19
 138:	82 e5       	ldi	r24, 0x52	; 82
 13a:	e8 2e       	mov	r14, r24
 13c:	82 e0       	ldi	r24, 0x02	; 2
 13e:	f8 2e       	mov	r15, r24
 140:	99 ea       	ldi	r25, 0xA9	; 169
 142:	89 2e       	mov	r8, r25
 144:	91 e0       	ldi	r25, 0x01	; 1
 146:	99 2e       	mov	r9, r25
 148:	3e 01       	movw	r6, r28
 14a:	4b e5       	ldi	r20, 0x5B	; 91
 14c:	64 1a       	sub	r6, r20
 14e:	4d ef       	ldi	r20, 0xFD	; 253
 150:	74 0a       	sbc	r7, r20
 152:	80 e0       	ldi	r24, 0x00	; 0
 154:	90 e0       	ldi	r25, 0x00	; 0
 156:	dc 01       	movw	r26, r24
    int8_t *xA = xM;
    int8_t *yM = matrixY + NR_MATRIX_ELEMENTS_MINUS_ONE;
    int8_t *yA = yM;
    int32_t *r = matrixR + NR_MATRIX_ELEMENTS_MINUS_ONE;
  
    register uint8_t e = NR_MATRIX_ELEMENTS;
 158:	29 ea       	ldi	r18, 0xA9	; 169
 15a:	b2 2e       	mov	r11, r18
    70,  108,  69,   12,   0,    80,   115,  107,  71,   54,   5,    57,   3,
    123, 72,   56,   5,    30,   45,   2,    11,   124,  84,   63,   47,   104};

    int8_t *xM = matrixX + NR_MATRIX_ELEMENTS_MINUS_ONE;
    int8_t *xA = xM;
    int8_t *yM = matrixY + NR_MATRIX_ELEMENTS_MINUS_ONE;
 15c:	68 ea       	ldi	r22, 0xA8	; 168
 15e:	71 e0       	ldi	r23, 0x01	; 1
    121, 42,   78,   45,   8,    17,   52,   38,   44,   13,   104,  57,   62,
    29,  96,   0,    64,   47,   50,   22,   17,   88,   63,   108,  78,   101,
    70,  108,  69,   12,   0,    80,   115,  107,  71,   54,   5,    57,   3,
    123, 72,   56,   5,    30,   45,   2,    11,   124,  84,   63,   47,   104};

    int8_t *xM = matrixX + NR_MATRIX_ELEMENTS_MINUS_ONE;
 160:	01 e5       	ldi	r16, 0x51	; 81
 162:	12 e0       	ldi	r17, 0x02	; 2
        yM += 168;
        --xA;
        --yA;
        --r;

        if(e%13 == 0){
 164:	3d e0       	ldi	r19, 0x0D	; 13
 166:	a3 2e       	mov	r10, r19
 168:	17 01       	movw	r2, r14
 16a:	6c 01       	movw	r12, r24
 16c:	7d 01       	movw	r14, r26
 16e:	d8 01       	movw	r26, r16
 170:	11 96       	adiw	r26, 0x01	; 1
 172:	ab 01       	movw	r20, r22
 174:	49 5a       	subi	r20, 0xA9	; 169
 176:	51 09       	sbc	r21, r1
    121, 42,   78,   45,   8,    17,   52,   38,   44,   13,   104,  57,   62,
    29,  96,   0,    64,   47,   50,   22,   17,   88,   63,   108,  78,   101,
    70,  108,  69,   12,   0,    80,   115,  107,  71,   54,   5,    57,   3,
    123, 72,   56,   5,    30,   45,   2,    11,   124,  84,   63,   47,   104};

    int8_t *xM = matrixX + NR_MATRIX_ELEMENTS_MINUS_ONE;
 178:	fb 01       	movw	r30, r22
 17a:	20 e0       	ldi	r18, 0x00	; 0
 17c:	30 e0       	ldi	r19, 0x00	; 0

    while(e>0){
        register int mBuffer = 0;
        for(k = NR_MATRIX_COLS; k > 0; --k)
        {
            mBuffer += *xM * *yM;
 17e:	9e 91       	ld	r25, -X
 180:	80 81       	ld	r24, Z
 182:	98 02       	muls	r25, r24
 184:	20 0d       	add	r18, r0
 186:	31 1d       	adc	r19, r1
 188:	11 24       	eor	r1, r1
            --xM;
            yM -= NR_MATRIX_COLS;
 18a:	3d 97       	sbiw	r30, 0x0d	; 13
    /*Start timer*/
    unsigned long startTime = micros();

    while(e>0){
        register int mBuffer = 0;
        for(k = NR_MATRIX_COLS; k > 0; --k)
 18c:	e4 17       	cp	r30, r20
 18e:	f5 07       	cpc	r31, r21
 190:	b1 f7       	brne	.-20     	; 0x17e <loop+0xae>
 192:	a8 01       	movw	r20, r16
 194:	4d 50       	subi	r20, 0x0D	; 13
 196:	51 09       	sbc	r21, r1
        {
            mBuffer += *xM * *yM;
            --xM;
            yM -= NR_MATRIX_COLS;
        }
        *r += *xA + *yA + mBuffer;
 198:	d1 01       	movw	r26, r2
 19a:	9e 91       	ld	r25, -X
 19c:	1d 01       	movw	r2, r26
 19e:	d4 01       	movw	r26, r8
 1a0:	ee 91       	ld	r30, -X
 1a2:	4d 01       	movw	r8, r26
 1a4:	0e 2e       	mov	r0, r30
 1a6:	00 0c       	add	r0, r0
 1a8:	ff 0b       	sbc	r31, r31
 1aa:	e9 0f       	add	r30, r25
 1ac:	f1 1d       	adc	r31, r1
 1ae:	97 fd       	sbrc	r25, 7
 1b0:	fa 95       	dec	r31
 1b2:	e2 0f       	add	r30, r18
 1b4:	f3 1f       	adc	r31, r19
 1b6:	cf 01       	movw	r24, r30
 1b8:	ff 0f       	add	r31, r31
 1ba:	aa 0b       	sbc	r26, r26
 1bc:	bb 0b       	sbc	r27, r27
 1be:	8c 0d       	add	r24, r12
 1c0:	9d 1d       	adc	r25, r13
 1c2:	ae 1d       	adc	r26, r14
 1c4:	bf 1d       	adc	r27, r15
 1c6:	f3 01       	movw	r30, r6
 1c8:	b2 93       	st	-Z, r27
 1ca:	a2 93       	st	-Z, r26
 1cc:	92 93       	st	-Z, r25
 1ce:	82 93       	st	-Z, r24
 1d0:	3f 01       	movw	r6, r30
        yM += 168;
        --xA;
        --yA;
        --r;

        if(e%13 == 0){
 1d2:	ff e4       	ldi	r31, 0x4F	; 79
 1d4:	bf 9e       	mul	r11, r31
 1d6:	81 2d       	mov	r24, r1
 1d8:	11 24       	eor	r1, r1
 1da:	86 95       	lsr	r24
 1dc:	86 95       	lsr	r24
 1de:	2b 2d       	mov	r18, r11
 1e0:	8a 9d       	mul	r24, r10
 1e2:	20 19       	sub	r18, r0
 1e4:	11 24       	eor	r1, r1
 1e6:	22 23       	and	r18, r18
 1e8:	61 f0       	breq	.+24     	; 0x202 <loop+0x132>
            --xM;
            yM -= NR_MATRIX_COLS;
        }
        *r += *xA + *yA + mBuffer;
        xM += 13;
        yM += 168;
 1ea:	61 50       	subi	r22, 0x01	; 1
 1ec:	71 09       	sbc	r23, r1
        if(e%13 == 0){
            xM -= 13;
            yM += 13;
        }

        --e;
 1ee:	ba 94       	dec	r11
    register uint8_t k = 0; 
  
    /*Start timer*/
    unsigned long startTime = micros();

    while(e>0){
 1f0:	bb 20       	and	r11, r11
 1f2:	69 f0       	breq	.+26     	; 0x20e <loop+0x13e>
 1f4:	d2 01       	movw	r26, r4
 1f6:	fe 90       	ld	r15, -X
 1f8:	ee 90       	ld	r14, -X
 1fa:	de 90       	ld	r13, -X
 1fc:	ce 90       	ld	r12, -X
 1fe:	2d 01       	movw	r4, r26
 200:	b6 cf       	rjmp	.-148    	; 0x16e <loop+0x9e>
        --yA;
        --r;

        if(e%13 == 0){
            xM -= 13;
            yM += 13;
 202:	64 5f       	subi	r22, 0xF4	; 244
 204:	7f 4f       	sbci	r23, 0xFF	; 255
    while(e>0){
        register int mBuffer = 0;
        for(k = NR_MATRIX_COLS; k > 0; --k)
        {
            mBuffer += *xM * *yM;
            --xM;
 206:	8a 01       	movw	r16, r20
        if(e%13 == 0){
            xM -= 13;
            yM += 13;
        }

        --e;
 208:	ba 94       	dec	r11
    register uint8_t k = 0; 
  
    /*Start timer*/
    unsigned long startTime = micros();

    while(e>0){
 20a:	b1 10       	cpse	r11, r1
 20c:	f3 cf       	rjmp	.-26     	; 0x1f4 <loop+0x124>

        --e;
    }
  
  //
  unsigned long currentTime = micros();
 20e:	0e 94 0e 04 	call	0x81c	; 0x81c <micros>
  unsigned long elapsedTime = currentTime - startTime;
 212:	6b 01       	movw	r12, r22
 214:	7c 01       	movw	r14, r24
 216:	cb 55       	subi	r28, 0x5B	; 91
 218:	dd 4f       	sbci	r29, 0xFD	; 253
 21a:	28 81       	ld	r18, Y
 21c:	39 81       	ldd	r19, Y+1	; 0x01
 21e:	4a 81       	ldd	r20, Y+2	; 0x02
 220:	5b 81       	ldd	r21, Y+3	; 0x03
 222:	c5 5a       	subi	r28, 0xA5	; 165
 224:	d2 40       	sbci	r29, 0x02	; 2
 226:	c2 1a       	sub	r12, r18
 228:	d3 0a       	sbc	r13, r19
 22a:	e4 0a       	sbc	r14, r20
 22c:	f5 0a       	sbc	r15, r21
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 22e:	42 e1       	ldi	r20, 0x12	; 18
 230:	50 e0       	ldi	r21, 0x00	; 0
 232:	62 e5       	ldi	r22, 0x52	; 82
 234:	72 e0       	ldi	r23, 0x02	; 2
 236:	86 e8       	ldi	r24, 0x86	; 134
 238:	92 e0       	ldi	r25, 0x02	; 2
 23a:	0e 94 19 03 	call	0x632	; 0x632 <_ZN5Print5writeEPKhj>

  //
  Serial.write("Elapsed time(us): ");
  Serial.println(elapsedTime);
 23e:	2a e0       	ldi	r18, 0x0A	; 10
 240:	30 e0       	ldi	r19, 0x00	; 0
 242:	b7 01       	movw	r22, r14
 244:	a6 01       	movw	r20, r12
 246:	86 e8       	ldi	r24, 0x86	; 134
 248:	92 e0       	ldi	r25, 0x02	; 2
}
 24a:	c8 55       	subi	r28, 0x58	; 88
 24c:	dd 4f       	sbci	r29, 0xFD	; 253
 24e:	0f b6       	in	r0, 0x3f	; 63
 250:	f8 94       	cli
 252:	de bf       	out	0x3e, r29	; 62
 254:	0f be       	out	0x3f, r0	; 63
 256:	cd bf       	out	0x3d, r28	; 61
 258:	df 91       	pop	r29
 25a:	cf 91       	pop	r28
 25c:	1f 91       	pop	r17
 25e:	0f 91       	pop	r16
 260:	ff 90       	pop	r15
 262:	ef 90       	pop	r14
 264:	df 90       	pop	r13
 266:	cf 90       	pop	r12
 268:	bf 90       	pop	r11
 26a:	af 90       	pop	r10
 26c:	9f 90       	pop	r9
 26e:	8f 90       	pop	r8
 270:	7f 90       	pop	r7
 272:	6f 90       	pop	r6
 274:	5f 90       	pop	r5
 276:	4f 90       	pop	r4
 278:	3f 90       	pop	r3
 27a:	2f 90       	pop	r2
  unsigned long currentTime = micros();
  unsigned long elapsedTime = currentTime - startTime;

  //
  Serial.write("Elapsed time(us): ");
  Serial.println(elapsedTime);
 27c:	0c 94 b2 03 	jmp	0x764	; 0x764 <_ZN5Print7printlnEmi>

00000280 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 280:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 282:	91 8d       	ldd	r25, Z+25	; 0x19
 284:	22 8d       	ldd	r18, Z+26	; 0x1a
 286:	89 2f       	mov	r24, r25
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	80 5c       	subi	r24, 0xC0	; 192
 28c:	9f 4f       	sbci	r25, 0xFF	; 255
 28e:	82 1b       	sub	r24, r18
 290:	91 09       	sbc	r25, r1
}
 292:	8f 73       	andi	r24, 0x3F	; 63
 294:	99 27       	eor	r25, r25
 296:	08 95       	ret

00000298 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
 298:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
 29a:	91 8d       	ldd	r25, Z+25	; 0x19
 29c:	82 8d       	ldd	r24, Z+26	; 0x1a
 29e:	98 17       	cp	r25, r24
 2a0:	31 f0       	breq	.+12     	; 0x2ae <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 2a2:	82 8d       	ldd	r24, Z+26	; 0x1a
 2a4:	e8 0f       	add	r30, r24
 2a6:	f1 1d       	adc	r31, r1
 2a8:	85 8d       	ldd	r24, Z+29	; 0x1d
 2aa:	90 e0       	ldi	r25, 0x00	; 0
 2ac:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 2ae:	8f ef       	ldi	r24, 0xFF	; 255
 2b0:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 2b2:	08 95       	ret

000002b4 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
 2b4:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 2b6:	91 8d       	ldd	r25, Z+25	; 0x19
 2b8:	82 8d       	ldd	r24, Z+26	; 0x1a
 2ba:	98 17       	cp	r25, r24
 2bc:	61 f0       	breq	.+24     	; 0x2d6 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 2be:	82 8d       	ldd	r24, Z+26	; 0x1a
 2c0:	df 01       	movw	r26, r30
 2c2:	a8 0f       	add	r26, r24
 2c4:	b1 1d       	adc	r27, r1
 2c6:	5d 96       	adiw	r26, 0x1d	; 29
 2c8:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 2ca:	92 8d       	ldd	r25, Z+26	; 0x1a
 2cc:	9f 5f       	subi	r25, 0xFF	; 255
 2ce:	9f 73       	andi	r25, 0x3F	; 63
 2d0:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 2d6:	8f ef       	ldi	r24, 0xFF	; 255
 2d8:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 2da:	08 95       	ret

000002dc <_ZN14HardwareSerial17availableForWriteEv>:
{
#if (SERIAL_TX_BUFFER_SIZE>256)
  uint8_t oldSREG = SREG;
  cli();
#endif
  tx_buffer_index_t head = _tx_buffer_head;
 2dc:	fc 01       	movw	r30, r24
 2de:	53 8d       	ldd	r21, Z+27	; 0x1b
  tx_buffer_index_t tail = _tx_buffer_tail;
 2e0:	44 8d       	ldd	r20, Z+28	; 0x1c
 2e2:	25 2f       	mov	r18, r21
 2e4:	30 e0       	ldi	r19, 0x00	; 0
 2e6:	84 2f       	mov	r24, r20
 2e8:	90 e0       	ldi	r25, 0x00	; 0
#if (SERIAL_TX_BUFFER_SIZE>256)
  SREG = oldSREG;
#endif
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 2ea:	82 1b       	sub	r24, r18
 2ec:	93 0b       	sbc	r25, r19
 2ee:	54 17       	cp	r21, r20
 2f0:	10 f0       	brcs	.+4      	; 0x2f6 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
 2f2:	cf 96       	adiw	r24, 0x3f	; 63
 2f4:	08 95       	ret
  return tail - head - 1;
 2f6:	01 97       	sbiw	r24, 0x01	; 1
}
 2f8:	08 95       	ret

000002fa <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2fa:	82 ed       	ldi	r24, 0xD2	; 210
 2fc:	92 e0       	ldi	r25, 0x02	; 2
 2fe:	89 2b       	or	r24, r25
 300:	49 f0       	breq	.+18     	; 0x314 <_Z14serialEventRunv+0x1a>
 302:	80 e0       	ldi	r24, 0x00	; 0
 304:	90 e0       	ldi	r25, 0x00	; 0
 306:	89 2b       	or	r24, r25
 308:	29 f0       	breq	.+10     	; 0x314 <_Z14serialEventRunv+0x1a>
 30a:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <_Z17Serial0_availablev>
 30e:	81 11       	cpse	r24, r1
 310:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
 314:	08 95       	ret

00000316 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 316:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 318:	84 8d       	ldd	r24, Z+28	; 0x1c
 31a:	df 01       	movw	r26, r30
 31c:	a8 0f       	add	r26, r24
 31e:	b1 1d       	adc	r27, r1
 320:	a3 5a       	subi	r26, 0xA3	; 163
 322:	bf 4f       	sbci	r27, 0xFF	; 255
 324:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 326:	84 8d       	ldd	r24, Z+28	; 0x1c
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	01 96       	adiw	r24, 0x01	; 1
 32c:	8f 73       	andi	r24, 0x3F	; 63
 32e:	99 27       	eor	r25, r25
 330:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
 332:	a6 89       	ldd	r26, Z+22	; 0x16
 334:	b7 89       	ldd	r27, Z+23	; 0x17
 336:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
 338:	a0 89       	ldd	r26, Z+16	; 0x10
 33a:	b1 89       	ldd	r27, Z+17	; 0x11
 33c:	8c 91       	ld	r24, X
 33e:	80 64       	ori	r24, 0x40	; 64
 340:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
 342:	93 8d       	ldd	r25, Z+27	; 0x1b
 344:	84 8d       	ldd	r24, Z+28	; 0x1c
 346:	98 13       	cpse	r25, r24
 348:	06 c0       	rjmp	.+12     	; 0x356 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 34a:	02 88       	ldd	r0, Z+18	; 0x12
 34c:	f3 89       	ldd	r31, Z+19	; 0x13
 34e:	e0 2d       	mov	r30, r0
 350:	80 81       	ld	r24, Z
 352:	8f 7d       	andi	r24, 0xDF	; 223
 354:	80 83       	st	Z, r24
 356:	08 95       	ret

00000358 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 358:	ef 92       	push	r14
 35a:	ff 92       	push	r15
 35c:	0f 93       	push	r16
 35e:	1f 93       	push	r17
 360:	cf 93       	push	r28
 362:	df 93       	push	r29
 364:	ec 01       	movw	r28, r24
  _written = true;
 366:	81 e0       	ldi	r24, 0x01	; 1
 368:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 36a:	9b 8d       	ldd	r25, Y+27	; 0x1b
 36c:	8c 8d       	ldd	r24, Y+28	; 0x1c
 36e:	98 13       	cpse	r25, r24
 370:	05 c0       	rjmp	.+10     	; 0x37c <_ZN14HardwareSerial5writeEh+0x24>
 372:	e8 89       	ldd	r30, Y+16	; 0x10
 374:	f9 89       	ldd	r31, Y+17	; 0x11
 376:	80 81       	ld	r24, Z
 378:	85 fd       	sbrc	r24, 5
 37a:	24 c0       	rjmp	.+72     	; 0x3c4 <_ZN14HardwareSerial5writeEh+0x6c>
 37c:	f6 2e       	mov	r15, r22
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 37e:	0b 8d       	ldd	r16, Y+27	; 0x1b
 380:	10 e0       	ldi	r17, 0x00	; 0
 382:	0f 5f       	subi	r16, 0xFF	; 255
 384:	1f 4f       	sbci	r17, 0xFF	; 255
 386:	0f 73       	andi	r16, 0x3F	; 63
 388:	11 27       	eor	r17, r17
 38a:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 38c:	8c 8d       	ldd	r24, Y+28	; 0x1c
 38e:	e8 12       	cpse	r14, r24
 390:	0c c0       	rjmp	.+24     	; 0x3aa <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
 392:	0f b6       	in	r0, 0x3f	; 63
 394:	07 fc       	sbrc	r0, 7
 396:	fa cf       	rjmp	.-12     	; 0x38c <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 398:	e8 89       	ldd	r30, Y+16	; 0x10
 39a:	f9 89       	ldd	r31, Y+17	; 0x11
 39c:	80 81       	ld	r24, Z
 39e:	85 ff       	sbrs	r24, 5
 3a0:	f5 cf       	rjmp	.-22     	; 0x38c <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
 3a2:	ce 01       	movw	r24, r28
 3a4:	0e 94 8b 01 	call	0x316	; 0x316 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 3a8:	f1 cf       	rjmp	.-30     	; 0x38c <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 3aa:	8b 8d       	ldd	r24, Y+27	; 0x1b
 3ac:	fe 01       	movw	r30, r28
 3ae:	e8 0f       	add	r30, r24
 3b0:	f1 1d       	adc	r31, r1
 3b2:	e3 5a       	subi	r30, 0xA3	; 163
 3b4:	ff 4f       	sbci	r31, 0xFF	; 255
 3b6:	f0 82       	st	Z, r15
  _tx_buffer_head = i;
 3b8:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
 3ba:	ea 89       	ldd	r30, Y+18	; 0x12
 3bc:	fb 89       	ldd	r31, Y+19	; 0x13
 3be:	80 81       	ld	r24, Z
 3c0:	80 62       	ori	r24, 0x20	; 32
 3c2:	07 c0       	rjmp	.+14     	; 0x3d2 <_ZN14HardwareSerial5writeEh+0x7a>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
 3c4:	ee 89       	ldd	r30, Y+22	; 0x16
 3c6:	ff 89       	ldd	r31, Y+23	; 0x17
 3c8:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
 3ca:	e8 89       	ldd	r30, Y+16	; 0x10
 3cc:	f9 89       	ldd	r31, Y+17	; 0x11
 3ce:	80 81       	ld	r24, Z
 3d0:	80 64       	ori	r24, 0x40	; 64
 3d2:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
 3d4:	81 e0       	ldi	r24, 0x01	; 1
 3d6:	90 e0       	ldi	r25, 0x00	; 0
 3d8:	df 91       	pop	r29
 3da:	cf 91       	pop	r28
 3dc:	1f 91       	pop	r17
 3de:	0f 91       	pop	r16
 3e0:	ff 90       	pop	r15
 3e2:	ef 90       	pop	r14
 3e4:	08 95       	ret

000003e6 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 3e6:	cf 93       	push	r28
 3e8:	df 93       	push	r29
 3ea:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 3ec:	88 8d       	ldd	r24, Y+24	; 0x18
 3ee:	88 23       	and	r24, r24
 3f0:	c9 f0       	breq	.+50     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 3f2:	ea 89       	ldd	r30, Y+18	; 0x12
 3f4:	fb 89       	ldd	r31, Y+19	; 0x13
 3f6:	80 81       	ld	r24, Z
 3f8:	85 fd       	sbrc	r24, 5
 3fa:	05 c0       	rjmp	.+10     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
 3fc:	a8 89       	ldd	r26, Y+16	; 0x10
 3fe:	b9 89       	ldd	r27, Y+17	; 0x11
 400:	8c 91       	ld	r24, X
 402:	86 fd       	sbrc	r24, 6
 404:	0f c0       	rjmp	.+30     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 406:	0f b6       	in	r0, 0x3f	; 63
 408:	07 fc       	sbrc	r0, 7
 40a:	f5 cf       	rjmp	.-22     	; 0x3f6 <_ZN14HardwareSerial5flushEv+0x10>
 40c:	80 81       	ld	r24, Z
 40e:	85 ff       	sbrs	r24, 5
 410:	f2 cf       	rjmp	.-28     	; 0x3f6 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 412:	a8 89       	ldd	r26, Y+16	; 0x10
 414:	b9 89       	ldd	r27, Y+17	; 0x11
 416:	8c 91       	ld	r24, X
 418:	85 ff       	sbrs	r24, 5
 41a:	ed cf       	rjmp	.-38     	; 0x3f6 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
 41c:	ce 01       	movw	r24, r28
 41e:	0e 94 8b 01 	call	0x316	; 0x316 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 422:	e7 cf       	rjmp	.-50     	; 0x3f2 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 424:	df 91       	pop	r29
 426:	cf 91       	pop	r28
 428:	08 95       	ret

0000042a <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
 42a:	cf 92       	push	r12
 42c:	df 92       	push	r13
 42e:	ef 92       	push	r14
 430:	ff 92       	push	r15
 432:	1f 93       	push	r17
 434:	cf 93       	push	r28
 436:	df 93       	push	r29
 438:	ec 01       	movw	r28, r24
 43a:	6a 01       	movw	r12, r20
 43c:	7b 01       	movw	r14, r22
 43e:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 440:	e8 89       	ldd	r30, Y+16	; 0x10
 442:	f9 89       	ldd	r31, Y+17	; 0x11
 444:	82 e0       	ldi	r24, 0x02	; 2
 446:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
 448:	41 15       	cp	r20, r1
 44a:	51 4e       	sbci	r21, 0xE1	; 225
 44c:	61 05       	cpc	r22, r1
 44e:	71 05       	cpc	r23, r1
 450:	b1 f0       	breq	.+44     	; 0x47e <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
 452:	60 e0       	ldi	r22, 0x00	; 0
 454:	79 e0       	ldi	r23, 0x09	; 9
 456:	8d e3       	ldi	r24, 0x3D	; 61
 458:	90 e0       	ldi	r25, 0x00	; 0
 45a:	a7 01       	movw	r20, r14
 45c:	96 01       	movw	r18, r12
 45e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <__udivmodsi4>
 462:	da 01       	movw	r26, r20
 464:	c9 01       	movw	r24, r18
 466:	01 97       	sbiw	r24, 0x01	; 1
 468:	a1 09       	sbc	r26, r1
 46a:	b1 09       	sbc	r27, r1
 46c:	b6 95       	lsr	r27
 46e:	a7 95       	ror	r26
 470:	97 95       	ror	r25
 472:	87 95       	ror	r24
 474:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
 476:	21 15       	cp	r18, r1
 478:	80 e1       	ldi	r24, 0x10	; 16
 47a:	38 07       	cpc	r19, r24
 47c:	a8 f0       	brcs	.+42     	; 0x4a8 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
 47e:	e8 89       	ldd	r30, Y+16	; 0x10
 480:	f9 89       	ldd	r31, Y+17	; 0x11
 482:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
 484:	60 e8       	ldi	r22, 0x80	; 128
 486:	74 e8       	ldi	r23, 0x84	; 132
 488:	8e e1       	ldi	r24, 0x1E	; 30
 48a:	90 e0       	ldi	r25, 0x00	; 0
 48c:	a7 01       	movw	r20, r14
 48e:	96 01       	movw	r18, r12
 490:	0e 94 6e 04 	call	0x8dc	; 0x8dc <__udivmodsi4>
 494:	da 01       	movw	r26, r20
 496:	c9 01       	movw	r24, r18
 498:	01 97       	sbiw	r24, 0x01	; 1
 49a:	a1 09       	sbc	r26, r1
 49c:	b1 09       	sbc	r27, r1
 49e:	b6 95       	lsr	r27
 4a0:	a7 95       	ror	r26
 4a2:	97 95       	ror	r25
 4a4:	87 95       	ror	r24
 4a6:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 4a8:	ec 85       	ldd	r30, Y+12	; 0x0c
 4aa:	fd 85       	ldd	r31, Y+13	; 0x0d
 4ac:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
 4ae:	ee 85       	ldd	r30, Y+14	; 0x0e
 4b0:	ff 85       	ldd	r31, Y+15	; 0x0f
 4b2:	20 83       	st	Z, r18

  _written = false;
 4b4:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 4b6:	ec 89       	ldd	r30, Y+20	; 0x14
 4b8:	fd 89       	ldd	r31, Y+21	; 0x15
 4ba:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
 4bc:	ea 89       	ldd	r30, Y+18	; 0x12
 4be:	fb 89       	ldd	r31, Y+19	; 0x13
 4c0:	80 81       	ld	r24, Z
 4c2:	80 61       	ori	r24, 0x10	; 16
 4c4:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
 4c6:	ea 89       	ldd	r30, Y+18	; 0x12
 4c8:	fb 89       	ldd	r31, Y+19	; 0x13
 4ca:	80 81       	ld	r24, Z
 4cc:	88 60       	ori	r24, 0x08	; 8
 4ce:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
 4d0:	ea 89       	ldd	r30, Y+18	; 0x12
 4d2:	fb 89       	ldd	r31, Y+19	; 0x13
 4d4:	80 81       	ld	r24, Z
 4d6:	80 68       	ori	r24, 0x80	; 128
 4d8:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
 4da:	ea 89       	ldd	r30, Y+18	; 0x12
 4dc:	fb 89       	ldd	r31, Y+19	; 0x13
 4de:	80 81       	ld	r24, Z
 4e0:	8f 7d       	andi	r24, 0xDF	; 223
 4e2:	80 83       	st	Z, r24
}
 4e4:	df 91       	pop	r29
 4e6:	cf 91       	pop	r28
 4e8:	1f 91       	pop	r17
 4ea:	ff 90       	pop	r15
 4ec:	ef 90       	pop	r14
 4ee:	df 90       	pop	r13
 4f0:	cf 90       	pop	r12
 4f2:	08 95       	ret

000004f4 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 4f4:	1f 92       	push	r1
 4f6:	0f 92       	push	r0
 4f8:	0f b6       	in	r0, 0x3f	; 63
 4fa:	0f 92       	push	r0
 4fc:	11 24       	eor	r1, r1
 4fe:	2f 93       	push	r18
 500:	8f 93       	push	r24
 502:	9f 93       	push	r25
 504:	ef 93       	push	r30
 506:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 508:	e0 91 96 02 	lds	r30, 0x0296	; 0x800296 <__data_end+0x10>
 50c:	f0 91 97 02 	lds	r31, 0x0297	; 0x800297 <__data_end+0x11>
 510:	80 81       	ld	r24, Z
 512:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end+0x16>
 516:	f0 91 9d 02 	lds	r31, 0x029D	; 0x80029d <__data_end+0x17>
 51a:	82 fd       	sbrc	r24, 2
 51c:	12 c0       	rjmp	.+36     	; 0x542 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 51e:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 520:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <__data_end+0x19>
 524:	8f 5f       	subi	r24, 0xFF	; 255
 526:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 528:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <__data_end+0x1a>
 52c:	82 17       	cp	r24, r18
 52e:	51 f0       	breq	.+20     	; 0x544 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
 530:	e0 91 9f 02 	lds	r30, 0x029F	; 0x80029f <__data_end+0x19>
 534:	f0 e0       	ldi	r31, 0x00	; 0
 536:	ea 57       	subi	r30, 0x7A	; 122
 538:	fd 4f       	sbci	r31, 0xFD	; 253
 53a:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
 53c:	80 93 9f 02 	sts	0x029F, r24	; 0x80029f <__data_end+0x19>
 540:	01 c0       	rjmp	.+2      	; 0x544 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 542:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
 544:	ff 91       	pop	r31
 546:	ef 91       	pop	r30
 548:	9f 91       	pop	r25
 54a:	8f 91       	pop	r24
 54c:	2f 91       	pop	r18
 54e:	0f 90       	pop	r0
 550:	0f be       	out	0x3f, r0	; 63
 552:	0f 90       	pop	r0
 554:	1f 90       	pop	r1
 556:	18 95       	reti

00000558 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 558:	1f 92       	push	r1
 55a:	0f 92       	push	r0
 55c:	0f b6       	in	r0, 0x3f	; 63
 55e:	0f 92       	push	r0
 560:	11 24       	eor	r1, r1
 562:	2f 93       	push	r18
 564:	3f 93       	push	r19
 566:	4f 93       	push	r20
 568:	5f 93       	push	r21
 56a:	6f 93       	push	r22
 56c:	7f 93       	push	r23
 56e:	8f 93       	push	r24
 570:	9f 93       	push	r25
 572:	af 93       	push	r26
 574:	bf 93       	push	r27
 576:	ef 93       	push	r30
 578:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
 57a:	86 e8       	ldi	r24, 0x86	; 134
 57c:	92 e0       	ldi	r25, 0x02	; 2
 57e:	0e 94 8b 01 	call	0x316	; 0x316 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
 582:	ff 91       	pop	r31
 584:	ef 91       	pop	r30
 586:	bf 91       	pop	r27
 588:	af 91       	pop	r26
 58a:	9f 91       	pop	r25
 58c:	8f 91       	pop	r24
 58e:	7f 91       	pop	r23
 590:	6f 91       	pop	r22
 592:	5f 91       	pop	r21
 594:	4f 91       	pop	r20
 596:	3f 91       	pop	r19
 598:	2f 91       	pop	r18
 59a:	0f 90       	pop	r0
 59c:	0f be       	out	0x3f, r0	; 63
 59e:	0f 90       	pop	r0
 5a0:	1f 90       	pop	r1
 5a2:	18 95       	reti

000005a4 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 5a4:	86 e8       	ldi	r24, 0x86	; 134
 5a6:	92 e0       	ldi	r25, 0x02	; 2
 5a8:	0e 94 40 01 	call	0x280	; 0x280 <_ZN14HardwareSerial9availableEv>
 5ac:	21 e0       	ldi	r18, 0x01	; 1
 5ae:	89 2b       	or	r24, r25
 5b0:	09 f4       	brne	.+2      	; 0x5b4 <_Z17Serial0_availablev+0x10>
 5b2:	20 e0       	ldi	r18, 0x00	; 0
}
 5b4:	82 2f       	mov	r24, r18
 5b6:	08 95       	ret

000005b8 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 5b8:	e6 e8       	ldi	r30, 0x86	; 134
 5ba:	f2 e0       	ldi	r31, 0x02	; 2
 5bc:	13 82       	std	Z+3, r1	; 0x03
 5be:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
 5c0:	88 ee       	ldi	r24, 0xE8	; 232
 5c2:	93 e0       	ldi	r25, 0x03	; 3
 5c4:	a0 e0       	ldi	r26, 0x00	; 0
 5c6:	b0 e0       	ldi	r27, 0x00	; 0
 5c8:	84 83       	std	Z+4, r24	; 0x04
 5ca:	95 83       	std	Z+5, r25	; 0x05
 5cc:	a6 83       	std	Z+6, r26	; 0x06
 5ce:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 5d0:	89 e6       	ldi	r24, 0x69	; 105
 5d2:	92 e0       	ldi	r25, 0x02	; 2
 5d4:	91 83       	std	Z+1, r25	; 0x01
 5d6:	80 83       	st	Z, r24
 5d8:	85 ec       	ldi	r24, 0xC5	; 197
 5da:	90 e0       	ldi	r25, 0x00	; 0
 5dc:	95 87       	std	Z+13, r25	; 0x0d
 5de:	84 87       	std	Z+12, r24	; 0x0c
 5e0:	84 ec       	ldi	r24, 0xC4	; 196
 5e2:	90 e0       	ldi	r25, 0x00	; 0
 5e4:	97 87       	std	Z+15, r25	; 0x0f
 5e6:	86 87       	std	Z+14, r24	; 0x0e
 5e8:	80 ec       	ldi	r24, 0xC0	; 192
 5ea:	90 e0       	ldi	r25, 0x00	; 0
 5ec:	91 8b       	std	Z+17, r25	; 0x11
 5ee:	80 8b       	std	Z+16, r24	; 0x10
 5f0:	81 ec       	ldi	r24, 0xC1	; 193
 5f2:	90 e0       	ldi	r25, 0x00	; 0
 5f4:	93 8b       	std	Z+19, r25	; 0x13
 5f6:	82 8b       	std	Z+18, r24	; 0x12
 5f8:	82 ec       	ldi	r24, 0xC2	; 194
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	95 8b       	std	Z+21, r25	; 0x15
 5fe:	84 8b       	std	Z+20, r24	; 0x14
 600:	86 ec       	ldi	r24, 0xC6	; 198
 602:	90 e0       	ldi	r25, 0x00	; 0
 604:	97 8b       	std	Z+23, r25	; 0x17
 606:	86 8b       	std	Z+22, r24	; 0x16
 608:	11 8e       	std	Z+25, r1	; 0x19
 60a:	12 8e       	std	Z+26, r1	; 0x1a
 60c:	13 8e       	std	Z+27, r1	; 0x1b
 60e:	14 8e       	std	Z+28, r1	; 0x1c
 610:	08 95       	ret

00000612 <initVariant>:
 612:	08 95       	ret

00000614 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
 614:	0e 94 33 04 	call	0x866	; 0x866 <init>

	initVariant();
 618:	0e 94 09 03 	call	0x612	; 0x612 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 61c:	0e 94 5f 00 	call	0xbe	; 0xbe <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 620:	cd e7       	ldi	r28, 0x7D	; 125
 622:	d1 e0       	ldi	r29, 0x01	; 1
#endif
	
	setup();
    
	for (;;) {
		loop();
 624:	0e 94 68 00 	call	0xd0	; 0xd0 <loop>
		if (serialEventRun) serialEventRun();
 628:	20 97       	sbiw	r28, 0x00	; 0
 62a:	e1 f3       	breq	.-8      	; 0x624 <main+0x10>
 62c:	0e 94 7d 01 	call	0x2fa	; 0x2fa <_Z14serialEventRunv>
 630:	f9 cf       	rjmp	.-14     	; 0x624 <main+0x10>

00000632 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
 632:	cf 92       	push	r12
 634:	df 92       	push	r13
 636:	ef 92       	push	r14
 638:	ff 92       	push	r15
 63a:	0f 93       	push	r16
 63c:	1f 93       	push	r17
 63e:	cf 93       	push	r28
 640:	df 93       	push	r29
 642:	6c 01       	movw	r12, r24
 644:	7a 01       	movw	r14, r20
 646:	8b 01       	movw	r16, r22
 648:	c0 e0       	ldi	r28, 0x00	; 0
 64a:	d0 e0       	ldi	r29, 0x00	; 0
 64c:	ce 15       	cp	r28, r14
 64e:	df 05       	cpc	r29, r15
 650:	81 f0       	breq	.+32     	; 0x672 <_ZN5Print5writeEPKhj+0x40>
 652:	d8 01       	movw	r26, r16
 654:	6d 91       	ld	r22, X+
 656:	8d 01       	movw	r16, r26
 658:	d6 01       	movw	r26, r12
 65a:	ed 91       	ld	r30, X+
 65c:	fc 91       	ld	r31, X
 65e:	01 90       	ld	r0, Z+
 660:	f0 81       	ld	r31, Z
 662:	e0 2d       	mov	r30, r0
 664:	c6 01       	movw	r24, r12
 666:	09 95       	icall
 668:	89 2b       	or	r24, r25
 66a:	11 f0       	breq	.+4      	; 0x670 <_ZN5Print5writeEPKhj+0x3e>
 66c:	21 96       	adiw	r28, 0x01	; 1
 66e:	ee cf       	rjmp	.-36     	; 0x64c <_ZN5Print5writeEPKhj+0x1a>
 670:	7e 01       	movw	r14, r28
 672:	c7 01       	movw	r24, r14
 674:	df 91       	pop	r29
 676:	cf 91       	pop	r28
 678:	1f 91       	pop	r17
 67a:	0f 91       	pop	r16
 67c:	ff 90       	pop	r15
 67e:	ef 90       	pop	r14
 680:	df 90       	pop	r13
 682:	cf 90       	pop	r12
 684:	08 95       	ret

00000686 <_ZN5Print5writeEPKc>:
 686:	61 15       	cp	r22, r1
 688:	71 05       	cpc	r23, r1
 68a:	79 f0       	breq	.+30     	; 0x6aa <_ZN5Print5writeEPKc+0x24>
 68c:	fb 01       	movw	r30, r22
 68e:	01 90       	ld	r0, Z+
 690:	00 20       	and	r0, r0
 692:	e9 f7       	brne	.-6      	; 0x68e <_ZN5Print5writeEPKc+0x8>
 694:	31 97       	sbiw	r30, 0x01	; 1
 696:	af 01       	movw	r20, r30
 698:	46 1b       	sub	r20, r22
 69a:	57 0b       	sbc	r21, r23
 69c:	dc 01       	movw	r26, r24
 69e:	ed 91       	ld	r30, X+
 6a0:	fc 91       	ld	r31, X
 6a2:	02 80       	ldd	r0, Z+2	; 0x02
 6a4:	f3 81       	ldd	r31, Z+3	; 0x03
 6a6:	e0 2d       	mov	r30, r0
 6a8:	09 94       	ijmp
 6aa:	80 e0       	ldi	r24, 0x00	; 0
 6ac:	90 e0       	ldi	r25, 0x00	; 0
 6ae:	08 95       	ret

000006b0 <_ZN5Print7printlnEv>:
 6b0:	67 e7       	ldi	r22, 0x77	; 119
 6b2:	72 e0       	ldi	r23, 0x02	; 2
 6b4:	0c 94 43 03 	jmp	0x686	; 0x686 <_ZN5Print5writeEPKc>

000006b8 <_ZN5Print11printNumberEmh>:
 6b8:	8f 92       	push	r8
 6ba:	9f 92       	push	r9
 6bc:	af 92       	push	r10
 6be:	bf 92       	push	r11
 6c0:	ef 92       	push	r14
 6c2:	ff 92       	push	r15
 6c4:	0f 93       	push	r16
 6c6:	1f 93       	push	r17
 6c8:	cf 93       	push	r28
 6ca:	df 93       	push	r29
 6cc:	cd b7       	in	r28, 0x3d	; 61
 6ce:	de b7       	in	r29, 0x3e	; 62
 6d0:	a1 97       	sbiw	r28, 0x21	; 33
 6d2:	0f b6       	in	r0, 0x3f	; 63
 6d4:	f8 94       	cli
 6d6:	de bf       	out	0x3e, r29	; 62
 6d8:	0f be       	out	0x3f, r0	; 63
 6da:	cd bf       	out	0x3d, r28	; 61
 6dc:	7c 01       	movw	r14, r24
 6de:	fa 01       	movw	r30, r20
 6e0:	cb 01       	movw	r24, r22
 6e2:	19 a2       	std	Y+33, r1	; 0x21
 6e4:	22 30       	cpi	r18, 0x02	; 2
 6e6:	08 f4       	brcc	.+2      	; 0x6ea <_ZN5Print11printNumberEmh+0x32>
 6e8:	2a e0       	ldi	r18, 0x0A	; 10
 6ea:	8e 01       	movw	r16, r28
 6ec:	0f 5d       	subi	r16, 0xDF	; 223
 6ee:	1f 4f       	sbci	r17, 0xFF	; 255
 6f0:	82 2e       	mov	r8, r18
 6f2:	91 2c       	mov	r9, r1
 6f4:	a1 2c       	mov	r10, r1
 6f6:	b1 2c       	mov	r11, r1
 6f8:	bf 01       	movw	r22, r30
 6fa:	a5 01       	movw	r20, r10
 6fc:	94 01       	movw	r18, r8
 6fe:	0e 94 6e 04 	call	0x8dc	; 0x8dc <__udivmodsi4>
 702:	f9 01       	movw	r30, r18
 704:	ca 01       	movw	r24, r20
 706:	01 50       	subi	r16, 0x01	; 1
 708:	11 09       	sbc	r17, r1
 70a:	6a 30       	cpi	r22, 0x0A	; 10
 70c:	10 f4       	brcc	.+4      	; 0x712 <_ZN5Print11printNumberEmh+0x5a>
 70e:	60 5d       	subi	r22, 0xD0	; 208
 710:	01 c0       	rjmp	.+2      	; 0x714 <_ZN5Print11printNumberEmh+0x5c>
 712:	69 5c       	subi	r22, 0xC9	; 201
 714:	d8 01       	movw	r26, r16
 716:	6c 93       	st	X, r22
 718:	23 2b       	or	r18, r19
 71a:	24 2b       	or	r18, r20
 71c:	25 2b       	or	r18, r21
 71e:	61 f7       	brne	.-40     	; 0x6f8 <_ZN5Print11printNumberEmh+0x40>
 720:	b8 01       	movw	r22, r16
 722:	c7 01       	movw	r24, r14
 724:	0e 94 43 03 	call	0x686	; 0x686 <_ZN5Print5writeEPKc>
 728:	a1 96       	adiw	r28, 0x21	; 33
 72a:	0f b6       	in	r0, 0x3f	; 63
 72c:	f8 94       	cli
 72e:	de bf       	out	0x3e, r29	; 62
 730:	0f be       	out	0x3f, r0	; 63
 732:	cd bf       	out	0x3d, r28	; 61
 734:	df 91       	pop	r29
 736:	cf 91       	pop	r28
 738:	1f 91       	pop	r17
 73a:	0f 91       	pop	r16
 73c:	ff 90       	pop	r15
 73e:	ef 90       	pop	r14
 740:	bf 90       	pop	r11
 742:	af 90       	pop	r10
 744:	9f 90       	pop	r9
 746:	8f 90       	pop	r8
 748:	08 95       	ret

0000074a <_ZN5Print5printEmi>:
 74a:	21 15       	cp	r18, r1
 74c:	31 05       	cpc	r19, r1
 74e:	41 f4       	brne	.+16     	; 0x760 <_ZN5Print5printEmi+0x16>
 750:	dc 01       	movw	r26, r24
 752:	ed 91       	ld	r30, X+
 754:	fc 91       	ld	r31, X
 756:	01 90       	ld	r0, Z+
 758:	f0 81       	ld	r31, Z
 75a:	e0 2d       	mov	r30, r0
 75c:	64 2f       	mov	r22, r20
 75e:	09 94       	ijmp
 760:	0c 94 5c 03 	jmp	0x6b8	; 0x6b8 <_ZN5Print11printNumberEmh>

00000764 <_ZN5Print7printlnEmi>:
  n += println();
  return n;
}

size_t Print::println(unsigned long num, int base)
{
 764:	0f 93       	push	r16
 766:	1f 93       	push	r17
 768:	cf 93       	push	r28
 76a:	df 93       	push	r29
 76c:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
 76e:	0e 94 a5 03 	call	0x74a	; 0x74a <_ZN5Print5printEmi>
 772:	8c 01       	movw	r16, r24
  n += println();
 774:	ce 01       	movw	r24, r28
 776:	0e 94 58 03 	call	0x6b0	; 0x6b0 <_ZN5Print7printlnEv>
  return n;
}
 77a:	80 0f       	add	r24, r16
 77c:	91 1f       	adc	r25, r17
 77e:	df 91       	pop	r29
 780:	cf 91       	pop	r28
 782:	1f 91       	pop	r17
 784:	0f 91       	pop	r16
 786:	08 95       	ret

00000788 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
 788:	1f 92       	push	r1
 78a:	0f 92       	push	r0
 78c:	0f b6       	in	r0, 0x3f	; 63
 78e:	0f 92       	push	r0
 790:	11 24       	eor	r1, r1
 792:	2f 93       	push	r18
 794:	3f 93       	push	r19
 796:	8f 93       	push	r24
 798:	9f 93       	push	r25
 79a:	af 93       	push	r26
 79c:	bf 93       	push	r27
 79e:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <timer0_millis>
 7a2:	90 91 25 03 	lds	r25, 0x0325	; 0x800325 <timer0_millis+0x1>
 7a6:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <timer0_millis+0x2>
 7aa:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <timer0_millis+0x3>
 7ae:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <timer0_fract>
 7b2:	23 e0       	ldi	r18, 0x03	; 3
 7b4:	23 0f       	add	r18, r19
 7b6:	2d 37       	cpi	r18, 0x7D	; 125
 7b8:	20 f4       	brcc	.+8      	; 0x7c2 <__vector_16+0x3a>
 7ba:	01 96       	adiw	r24, 0x01	; 1
 7bc:	a1 1d       	adc	r26, r1
 7be:	b1 1d       	adc	r27, r1
 7c0:	05 c0       	rjmp	.+10     	; 0x7cc <__vector_16+0x44>
 7c2:	26 e8       	ldi	r18, 0x86	; 134
 7c4:	23 0f       	add	r18, r19
 7c6:	02 96       	adiw	r24, 0x02	; 2
 7c8:	a1 1d       	adc	r26, r1
 7ca:	b1 1d       	adc	r27, r1
 7cc:	20 93 23 03 	sts	0x0323, r18	; 0x800323 <timer0_fract>
 7d0:	80 93 24 03 	sts	0x0324, r24	; 0x800324 <timer0_millis>
 7d4:	90 93 25 03 	sts	0x0325, r25	; 0x800325 <timer0_millis+0x1>
 7d8:	a0 93 26 03 	sts	0x0326, r26	; 0x800326 <timer0_millis+0x2>
 7dc:	b0 93 27 03 	sts	0x0327, r27	; 0x800327 <timer0_millis+0x3>
 7e0:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <timer0_overflow_count>
 7e4:	90 91 29 03 	lds	r25, 0x0329	; 0x800329 <timer0_overflow_count+0x1>
 7e8:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <timer0_overflow_count+0x2>
 7ec:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <timer0_overflow_count+0x3>
 7f0:	01 96       	adiw	r24, 0x01	; 1
 7f2:	a1 1d       	adc	r26, r1
 7f4:	b1 1d       	adc	r27, r1
 7f6:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <timer0_overflow_count>
 7fa:	90 93 29 03 	sts	0x0329, r25	; 0x800329 <timer0_overflow_count+0x1>
 7fe:	a0 93 2a 03 	sts	0x032A, r26	; 0x80032a <timer0_overflow_count+0x2>
 802:	b0 93 2b 03 	sts	0x032B, r27	; 0x80032b <timer0_overflow_count+0x3>
 806:	bf 91       	pop	r27
 808:	af 91       	pop	r26
 80a:	9f 91       	pop	r25
 80c:	8f 91       	pop	r24
 80e:	3f 91       	pop	r19
 810:	2f 91       	pop	r18
 812:	0f 90       	pop	r0
 814:	0f be       	out	0x3f, r0	; 63
 816:	0f 90       	pop	r0
 818:	1f 90       	pop	r1
 81a:	18 95       	reti

0000081c <micros>:
 81c:	3f b7       	in	r19, 0x3f	; 63
 81e:	f8 94       	cli
 820:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <timer0_overflow_count>
 824:	90 91 29 03 	lds	r25, 0x0329	; 0x800329 <timer0_overflow_count+0x1>
 828:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <timer0_overflow_count+0x2>
 82c:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <timer0_overflow_count+0x3>
 830:	26 b5       	in	r18, 0x26	; 38
 832:	a8 9b       	sbis	0x15, 0	; 21
 834:	05 c0       	rjmp	.+10     	; 0x840 <micros+0x24>
 836:	2f 3f       	cpi	r18, 0xFF	; 255
 838:	19 f0       	breq	.+6      	; 0x840 <micros+0x24>
 83a:	01 96       	adiw	r24, 0x01	; 1
 83c:	a1 1d       	adc	r26, r1
 83e:	b1 1d       	adc	r27, r1
 840:	3f bf       	out	0x3f, r19	; 63
 842:	ba 2f       	mov	r27, r26
 844:	a9 2f       	mov	r26, r25
 846:	98 2f       	mov	r25, r24
 848:	88 27       	eor	r24, r24
 84a:	82 0f       	add	r24, r18
 84c:	91 1d       	adc	r25, r1
 84e:	a1 1d       	adc	r26, r1
 850:	b1 1d       	adc	r27, r1
 852:	bc 01       	movw	r22, r24
 854:	cd 01       	movw	r24, r26
 856:	42 e0       	ldi	r20, 0x02	; 2
 858:	66 0f       	add	r22, r22
 85a:	77 1f       	adc	r23, r23
 85c:	88 1f       	adc	r24, r24
 85e:	99 1f       	adc	r25, r25
 860:	4a 95       	dec	r20
 862:	d1 f7       	brne	.-12     	; 0x858 <micros+0x3c>
 864:	08 95       	ret

00000866 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 866:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 868:	84 b5       	in	r24, 0x24	; 36
 86a:	82 60       	ori	r24, 0x02	; 2
 86c:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 86e:	84 b5       	in	r24, 0x24	; 36
 870:	81 60       	ori	r24, 0x01	; 1
 872:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 874:	85 b5       	in	r24, 0x25	; 37
 876:	82 60       	ori	r24, 0x02	; 2
 878:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 87a:	85 b5       	in	r24, 0x25	; 37
 87c:	81 60       	ori	r24, 0x01	; 1
 87e:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 880:	ee e6       	ldi	r30, 0x6E	; 110
 882:	f0 e0       	ldi	r31, 0x00	; 0
 884:	80 81       	ld	r24, Z
 886:	81 60       	ori	r24, 0x01	; 1
 888:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 88a:	e1 e8       	ldi	r30, 0x81	; 129
 88c:	f0 e0       	ldi	r31, 0x00	; 0
 88e:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 890:	80 81       	ld	r24, Z
 892:	82 60       	ori	r24, 0x02	; 2
 894:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 896:	80 81       	ld	r24, Z
 898:	81 60       	ori	r24, 0x01	; 1
 89a:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 89c:	e0 e8       	ldi	r30, 0x80	; 128
 89e:	f0 e0       	ldi	r31, 0x00	; 0
 8a0:	80 81       	ld	r24, Z
 8a2:	81 60       	ori	r24, 0x01	; 1
 8a4:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 8a6:	e1 eb       	ldi	r30, 0xB1	; 177
 8a8:	f0 e0       	ldi	r31, 0x00	; 0
 8aa:	80 81       	ld	r24, Z
 8ac:	84 60       	ori	r24, 0x04	; 4
 8ae:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 8b0:	e0 eb       	ldi	r30, 0xB0	; 176
 8b2:	f0 e0       	ldi	r31, 0x00	; 0
 8b4:	80 81       	ld	r24, Z
 8b6:	81 60       	ori	r24, 0x01	; 1
 8b8:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 8ba:	ea e7       	ldi	r30, 0x7A	; 122
 8bc:	f0 e0       	ldi	r31, 0x00	; 0
 8be:	80 81       	ld	r24, Z
 8c0:	84 60       	ori	r24, 0x04	; 4
 8c2:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 8c4:	80 81       	ld	r24, Z
 8c6:	82 60       	ori	r24, 0x02	; 2
 8c8:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 8ca:	80 81       	ld	r24, Z
 8cc:	81 60       	ori	r24, 0x01	; 1
 8ce:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 8d0:	80 81       	ld	r24, Z
 8d2:	80 68       	ori	r24, 0x80	; 128
 8d4:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 8d6:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 8da:	08 95       	ret

000008dc <__udivmodsi4>:
 8dc:	a1 e2       	ldi	r26, 0x21	; 33
 8de:	1a 2e       	mov	r1, r26
 8e0:	aa 1b       	sub	r26, r26
 8e2:	bb 1b       	sub	r27, r27
 8e4:	fd 01       	movw	r30, r26
 8e6:	0d c0       	rjmp	.+26     	; 0x902 <__udivmodsi4_ep>

000008e8 <__udivmodsi4_loop>:
 8e8:	aa 1f       	adc	r26, r26
 8ea:	bb 1f       	adc	r27, r27
 8ec:	ee 1f       	adc	r30, r30
 8ee:	ff 1f       	adc	r31, r31
 8f0:	a2 17       	cp	r26, r18
 8f2:	b3 07       	cpc	r27, r19
 8f4:	e4 07       	cpc	r30, r20
 8f6:	f5 07       	cpc	r31, r21
 8f8:	20 f0       	brcs	.+8      	; 0x902 <__udivmodsi4_ep>
 8fa:	a2 1b       	sub	r26, r18
 8fc:	b3 0b       	sbc	r27, r19
 8fe:	e4 0b       	sbc	r30, r20
 900:	f5 0b       	sbc	r31, r21

00000902 <__udivmodsi4_ep>:
 902:	66 1f       	adc	r22, r22
 904:	77 1f       	adc	r23, r23
 906:	88 1f       	adc	r24, r24
 908:	99 1f       	adc	r25, r25
 90a:	1a 94       	dec	r1
 90c:	69 f7       	brne	.-38     	; 0x8e8 <__udivmodsi4_loop>
 90e:	60 95       	com	r22
 910:	70 95       	com	r23
 912:	80 95       	com	r24
 914:	90 95       	com	r25
 916:	9b 01       	movw	r18, r22
 918:	ac 01       	movw	r20, r24
 91a:	bd 01       	movw	r22, r26
 91c:	cf 01       	movw	r24, r30
 91e:	08 95       	ret

00000920 <__tablejump2__>:
 920:	ee 0f       	add	r30, r30
 922:	ff 1f       	adc	r31, r31
 924:	05 90       	lpm	r0, Z+
 926:	f4 91       	lpm	r31, Z
 928:	e0 2d       	mov	r30, r0
 92a:	09 94       	ijmp

0000092c <_exit>:
 92c:	f8 94       	cli

0000092e <__stop_program>:
 92e:	ff cf       	rjmp	.-2      	; 0x92e <__stop_program>
