
Assignment_1.ino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000186  00800100  00000a94  00000b28  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a94  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a6  00800286  00800286  00000cae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000ce0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000248  00000000  00000000  00000d20  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000072df  00000000  00000000  00000f68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016b5  00000000  00000000  00008247  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014ea  00000000  00000000  000098fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000744  00000000  00000000  0000ade8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001fd4  00000000  00000000  0000b52c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002978  00000000  00000000  0000d500  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  0000fe78  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 76 04 	jmp	0x8ec	; 0x8ec <__vector_16>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__vector_18>
  4c:	0c 94 0f 03 	jmp	0x61e	; 0x61e <__vector_19>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
  68:	3f 03       	fmul	r19, r23

0000006a <__ctors_end>:
  6a:	11 24       	eor	r1, r1
  6c:	1f be       	out	0x3f, r1	; 63
  6e:	cf ef       	ldi	r28, 0xFF	; 255
  70:	d8 e0       	ldi	r29, 0x08	; 8
  72:	de bf       	out	0x3e, r29	; 62
  74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
  76:	12 e0       	ldi	r17, 0x02	; 2
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	e4 e9       	ldi	r30, 0x94	; 148
  7e:	fa e0       	ldi	r31, 0x0A	; 10
  80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
  82:	05 90       	lpm	r0, Z+
  84:	0d 92       	st	X+, r0
  86:	a6 38       	cpi	r26, 0x86	; 134
  88:	b1 07       	cpc	r27, r17
  8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
  8c:	23 e0       	ldi	r18, 0x03	; 3
  8e:	a6 e8       	ldi	r26, 0x86	; 134
  90:	b2 e0       	ldi	r27, 0x02	; 2
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	ac 32       	cpi	r26, 0x2C	; 44
  98:	b2 07       	cpc	r27, r18
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	c5 e3       	ldi	r28, 0x35	; 53
  a0:	d0 e0       	ldi	r29, 0x00	; 0
  a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
  a4:	21 97       	sbiw	r28, 0x01	; 1
  a6:	fe 01       	movw	r30, r28
  a8:	0e 94 42 05 	call	0xa84	; 0xa84 <__tablejump2__>
  ac:	c4 33       	cpi	r28, 0x34	; 52
  ae:	d1 07       	cpc	r29, r17
  b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
  b2:	0e 94 6d 03 	call	0x6da	; 0x6da <main>
  b6:	0c 94 48 05 	jmp	0xa90	; 0xa90 <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
  be:	26 e0       	ldi	r18, 0x06	; 6
  c0:	40 e8       	ldi	r20, 0x80	; 128
  c2:	55 e2       	ldi	r21, 0x25	; 37
  c4:	60 e0       	ldi	r22, 0x00	; 0
  c6:	70 e0       	ldi	r23, 0x00	; 0
  c8:	86 e8       	ldi	r24, 0x86	; 134
  ca:	92 e0       	ldi	r25, 0x02	; 2
  cc:	0e 94 78 02 	call	0x4f0	; 0x4f0 <_ZN14HardwareSerial5beginEmh>
  d0:	08 95       	ret

000000d2 <loop>:
  // put your setup code here, to run once:
  // initialize serial:
  Serial.begin(9600);
}

void loop() {
  d2:	3f 92       	push	r3
  d4:	4f 92       	push	r4
  d6:	5f 92       	push	r5
  d8:	6f 92       	push	r6
  da:	7f 92       	push	r7
  dc:	8f 92       	push	r8
  de:	9f 92       	push	r9
  e0:	af 92       	push	r10
  e2:	bf 92       	push	r11
  e4:	cf 92       	push	r12
  e6:	df 92       	push	r13
  e8:	ef 92       	push	r14
  ea:	ff 92       	push	r15
  ec:	0f 93       	push	r16
  ee:	1f 93       	push	r17
  f0:	cf 93       	push	r28
  f2:	df 93       	push	r29
  f4:	cd b7       	in	r28, 0x3d	; 61
  f6:	de b7       	in	r29, 0x3e	; 62
  f8:	cc 5a       	subi	r28, 0xAC	; 172
  fa:	d2 40       	sbci	r29, 0x02	; 2
  fc:	0f b6       	in	r0, 0x3f	; 63
  fe:	f8 94       	cli
 100:	de bf       	out	0x3e, r29	; 62
 102:	0f be       	out	0x3f, r0	; 63
 104:	cd bf       	out	0x3d, r28	; 61
  // put your main code here, to run repeatedly:
   
    int32_t matrixR[NR_MATRIX_ELEMENTS] = {0};
 106:	fe 01       	movw	r30, r28
 108:	31 96       	adiw	r30, 0x01	; 1
 10a:	84 ea       	ldi	r24, 0xA4	; 164
 10c:	92 e0       	ldi	r25, 0x02	; 2
 10e:	df 01       	movw	r26, r30
 110:	9c 01       	movw	r18, r24
 112:	1d 92       	st	X+, r1
 114:	21 50       	subi	r18, 0x01	; 1
 116:	30 40       	sbci	r19, 0x00	; 0
 118:	e1 f7       	brne	.-8      	; 0x112 <loop+0x40>
    register uint8_t k = 0; 
	register uint8_t i = 13;
	register uint32_t mBuffer = 0;
  
    /*Start timer*/
    unsigned long startTime = micros();
 11a:	0e 94 c0 04 	call	0x980	; 0x980 <micros>
 11e:	c7 55       	subi	r28, 0x57	; 87
 120:	dd 4f       	sbci	r29, 0xFD	; 253
 122:	68 83       	st	Y, r22
 124:	79 83       	std	Y+1, r23	; 0x01
 126:	8a 83       	std	Y+2, r24	; 0x02
 128:	9b 83       	std	Y+3, r25	; 0x03
 12a:	c9 5a       	subi	r28, 0xA9	; 169
 12c:	d2 40       	sbci	r29, 0x02	; 2
 12e:	62 e5       	ldi	r22, 0x52	; 82
 130:	72 e0       	ldi	r23, 0x02	; 2
 132:	49 ea       	ldi	r20, 0xA9	; 169
 134:	51 e0       	ldi	r21, 0x01	; 1
 136:	c9 55       	subi	r28, 0x59	; 89
 138:	dd 4f       	sbci	r29, 0xFD	; 253
 13a:	59 83       	std	Y+1, r21	; 0x01
 13c:	48 83       	st	Y, r20
 13e:	c7 5a       	subi	r28, 0xA7	; 167
 140:	d2 40       	sbci	r29, 0x02	; 2
    int8_t *yA = yM;
    int32_t *r = matrixR + NR_MATRIX_ELEMENTS_MINUS_ONE;
  
    register uint8_t e = NR_MATRIX_ELEMENTS;
    register uint8_t k = 0; 
	register uint8_t i = 13;
 142:	0f 2e       	mov	r0, r31
 144:	fd e0       	ldi	r31, 0x0D	; 13
 146:	3f 2e       	mov	r3, r31
 148:	f0 2d       	mov	r31, r0

    int8_t *xM = matrixX + NR_MATRIX_ELEMENTS_MINUS_ONE;
    int8_t *xA = xM;
    int8_t *yM = matrixY + NR_MATRIX_ELEMENTS_MINUS_ONE;
    int8_t *yA = yM;
    int32_t *r = matrixR + NR_MATRIX_ELEMENTS_MINUS_ONE;
 14a:	8e 01       	movw	r16, r28
 14c:	0f 55       	subi	r16, 0x5F	; 95
 14e:	1d 4f       	sbci	r17, 0xFD	; 253
    70,  108,  69,   12,   0,    80,   115,  107,  71,   54,   5,    57,   3,
    123, 72,   56,   5,    30,   45,   2,    11,   124,  84,   63,   47,   104};

    int8_t *xM = matrixX + NR_MATRIX_ELEMENTS_MINUS_ONE;
    int8_t *xA = xM;
    int8_t *yM = matrixY + NR_MATRIX_ELEMENTS_MINUS_ONE;
 150:	0f 2e       	mov	r0, r31
 152:	f8 ea       	ldi	r31, 0xA8	; 168
 154:	cf 2e       	mov	r12, r31
 156:	f1 e0       	ldi	r31, 0x01	; 1
 158:	df 2e       	mov	r13, r31
 15a:	f0 2d       	mov	r31, r0
    121, 42,   78,   45,   8,    17,   52,   38,   44,   13,   104,  57,   62,
    29,  96,   0,    64,   47,   50,   22,   17,   88,   63,   108,  78,   101,
    70,  108,  69,   12,   0,    80,   115,  107,  71,   54,   5,    57,   3,
    123, 72,   56,   5,    30,   45,   2,    11,   124,  84,   63,   47,   104};

    int8_t *xM = matrixX + NR_MATRIX_ELEMENTS_MINUS_ONE;
 15c:	0f 2e       	mov	r0, r31
 15e:	f1 e5       	ldi	r31, 0x51	; 81
 160:	ef 2e       	mov	r14, r31
 162:	f2 e0       	ldi	r31, 0x02	; 2
 164:	ff 2e       	mov	r15, r31
 166:	f0 2d       	mov	r31, r0
	register uint32_t mBuffer = 0;
  
    /*Start timer*/
    unsigned long startTime = micros();
	
    while(e>0){
 168:	ce 01       	movw	r24, r28
 16a:	03 97       	sbiw	r24, 0x03	; 3
 16c:	cb 55       	subi	r28, 0x5B	; 91
 16e:	dd 4f       	sbci	r29, 0xFD	; 253
 170:	99 83       	std	Y+1, r25	; 0x01
 172:	88 83       	st	Y, r24
 174:	c5 5a       	subi	r28, 0xA5	; 165
 176:	d2 40       	sbci	r29, 0x02	; 2
        
		mBuffer = 0;
		
		
		mBuffer += *xM * *yM;
 178:	d7 01       	movw	r26, r14
 17a:	8c 91       	ld	r24, X
 17c:	f6 01       	movw	r30, r12
 17e:	90 81       	ld	r25, Z
 180:	89 02       	muls	r24, r25
 182:	20 01       	movw	r4, r0
 184:	11 24       	eor	r1, r1
 186:	05 2c       	mov	r0, r5
 188:	00 0c       	add	r0, r0
 18a:	66 08       	sbc	r6, r6
 18c:	77 08       	sbc	r7, r7
 18e:	f7 01       	movw	r30, r14
 190:	32 97       	sbiw	r30, 0x02	; 2
 192:	96 01       	movw	r18, r12
 194:	2a 51       	subi	r18, 0x1A	; 26
 196:	31 09       	sbc	r19, r1
 198:	a7 01       	movw	r20, r14
 19a:	4e 50       	subi	r20, 0x0E	; 14
 19c:	51 09       	sbc	r21, r1
			mBuffer += *xM * *yM;
			
			/**/
			--xM;
			yM -= NR_MATRIX_COLS;
			mBuffer += *xM * *yM;
 19e:	81 81       	ldd	r24, Z+1	; 0x01
 1a0:	d9 01       	movw	r26, r18
 1a2:	1d 96       	adiw	r26, 0x0d	; 13
 1a4:	9c 91       	ld	r25, X
 1a6:	1d 97       	sbiw	r26, 0x0d	; 13
 1a8:	89 02       	muls	r24, r25
 1aa:	c0 01       	movw	r24, r0
 1ac:	11 24       	eor	r1, r1
 1ae:	4c 01       	movw	r8, r24
 1b0:	99 0f       	add	r25, r25
 1b2:	aa 08       	sbc	r10, r10
 1b4:	bb 08       	sbc	r11, r11
 1b6:	90 81       	ld	r25, Z
 1b8:	8c 91       	ld	r24, X
 1ba:	98 02       	muls	r25, r24
 1bc:	c0 01       	movw	r24, r0
 1be:	11 24       	eor	r1, r1
 1c0:	09 2e       	mov	r0, r25
 1c2:	00 0c       	add	r0, r0
 1c4:	aa 0b       	sbc	r26, r26
 1c6:	bb 0b       	sbc	r27, r27
 1c8:	88 0d       	add	r24, r8
 1ca:	99 1d       	adc	r25, r9
 1cc:	aa 1d       	adc	r26, r10
 1ce:	bb 1d       	adc	r27, r11
 1d0:	48 0e       	add	r4, r24
 1d2:	59 1e       	adc	r5, r25
 1d4:	6a 1e       	adc	r6, r26
 1d6:	7b 1e       	adc	r7, r27
 1d8:	32 97       	sbiw	r30, 0x02	; 2
 1da:	2a 51       	subi	r18, 0x1A	; 26
 1dc:	31 09       	sbc	r19, r1
        
		mBuffer = 0;
		
		
		mBuffer += *xM * *yM;
        for(k = NR_MATRIX_COLS-1; k > 0; k-=2){        
 1de:	4e 17       	cp	r20, r30
 1e0:	5f 07       	cpc	r21, r31
 1e2:	e9 f6       	brne	.-70     	; 0x19e <loop+0xcc>
		
		
		xM += 12;
		yM += 155;
		
        *r += *xA + *yA + mBuffer;
 1e4:	fb 01       	movw	r30, r22
 1e6:	22 91       	ld	r18, -Z
 1e8:	bf 01       	movw	r22, r30
 1ea:	c9 55       	subi	r28, 0x59	; 89
 1ec:	dd 4f       	sbci	r29, 0xFD	; 253
 1ee:	a8 81       	ld	r26, Y
 1f0:	b9 81       	ldd	r27, Y+1	; 0x01
 1f2:	c7 5a       	subi	r28, 0xA7	; 167
 1f4:	d2 40       	sbci	r29, 0x02	; 2
 1f6:	8e 91       	ld	r24, -X
 1f8:	c9 55       	subi	r28, 0x59	; 89
 1fa:	dd 4f       	sbci	r29, 0xFD	; 253
 1fc:	b9 83       	std	Y+1, r27	; 0x01
 1fe:	a8 83       	st	Y, r26
 200:	c7 5a       	subi	r28, 0xA7	; 167
 202:	d2 40       	sbci	r29, 0x02	; 2
 204:	08 2e       	mov	r0, r24
 206:	00 0c       	add	r0, r0
 208:	99 0b       	sbc	r25, r25
 20a:	82 0f       	add	r24, r18
 20c:	91 1d       	adc	r25, r1
 20e:	27 fd       	sbrc	r18, 7
 210:	9a 95       	dec	r25
 212:	09 2e       	mov	r0, r25
 214:	00 0c       	add	r0, r0
 216:	aa 0b       	sbc	r26, r26
 218:	bb 0b       	sbc	r27, r27
 21a:	f8 01       	movw	r30, r16
 21c:	20 81       	ld	r18, Z
 21e:	31 81       	ldd	r19, Z+1	; 0x01
 220:	42 81       	ldd	r20, Z+2	; 0x02
 222:	53 81       	ldd	r21, Z+3	; 0x03
 224:	82 0f       	add	r24, r18
 226:	93 1f       	adc	r25, r19
 228:	a4 1f       	adc	r26, r20
 22a:	b5 1f       	adc	r27, r21
 22c:	48 0e       	add	r4, r24
 22e:	59 1e       	adc	r5, r25
 230:	6a 1e       	adc	r6, r26
 232:	7b 1e       	adc	r7, r27
 234:	40 82       	st	Z, r4
 236:	51 82       	std	Z+1, r5	; 0x01
 238:	62 82       	std	Z+2, r6	; 0x02
 23a:	73 82       	std	Z+3, r7	; 0x03
        

        if(--i == 0){
 23c:	3a 94       	dec	r3
 23e:	33 20       	and	r3, r3
 240:	21 f0       	breq	.+8      	; 0x24a <loop+0x178>
			mBuffer += *xM * *yM;
        }
		
		
		xM += 12;
		yM += 155;
 242:	b1 e0       	ldi	r27, 0x01	; 1
 244:	cb 1a       	sub	r12, r27
 246:	d1 08       	sbc	r13, r1
 248:	0a c0       	rjmp	.+20     	; 0x25e <loop+0x18c>
        *r += *xA + *yA + mBuffer;
        

        if(--i == 0){
			i = 13;
            xM -= 13;
 24a:	ed e0       	ldi	r30, 0x0D	; 13
 24c:	ee 1a       	sub	r14, r30
 24e:	f1 08       	sbc	r15, r1
            yM += 13;
 250:	fc e0       	ldi	r31, 0x0C	; 12
 252:	cf 0e       	add	r12, r31
 254:	d1 1c       	adc	r13, r1
		
        *r += *xA + *yA + mBuffer;
        

        if(--i == 0){
			i = 13;
 256:	0f 2e       	mov	r0, r31
 258:	fd e0       	ldi	r31, 0x0D	; 13
 25a:	3f 2e       	mov	r3, r31
 25c:	f0 2d       	mov	r31, r0
            yM += 13;
        }
		
		--xA;
		--yA;
		--r;
 25e:	04 50       	subi	r16, 0x04	; 4
 260:	11 09       	sbc	r17, r1
	register uint32_t mBuffer = 0;
  
    /*Start timer*/
    unsigned long startTime = micros();
	
    while(e>0){
 262:	cb 55       	subi	r28, 0x5B	; 91
 264:	dd 4f       	sbci	r29, 0xFD	; 253
 266:	28 81       	ld	r18, Y
 268:	39 81       	ldd	r19, Y+1	; 0x01
 26a:	c5 5a       	subi	r28, 0xA5	; 165
 26c:	d2 40       	sbci	r29, 0x02	; 2
 26e:	02 17       	cp	r16, r18
 270:	13 07       	cpc	r17, r19
 272:	09 f0       	breq	.+2      	; 0x276 <loop+0x1a4>
 274:	81 cf       	rjmp	.-254    	; 0x178 <loop+0xa6>
		--e;

    }
  
  //
  unsigned long currentTime = micros();
 276:	0e 94 c0 04 	call	0x980	; 0x980 <micros>
  unsigned long elapsedTime = currentTime - startTime;
 27a:	6b 01       	movw	r12, r22
 27c:	7c 01       	movw	r14, r24
 27e:	c7 55       	subi	r28, 0x57	; 87
 280:	dd 4f       	sbci	r29, 0xFD	; 253
 282:	28 81       	ld	r18, Y
 284:	39 81       	ldd	r19, Y+1	; 0x01
 286:	4a 81       	ldd	r20, Y+2	; 0x02
 288:	5b 81       	ldd	r21, Y+3	; 0x03
 28a:	c9 5a       	subi	r28, 0xA9	; 169
 28c:	d2 40       	sbci	r29, 0x02	; 2
 28e:	c2 1a       	sub	r12, r18
 290:	d3 0a       	sbc	r13, r19
 292:	e4 0a       	sbc	r14, r20
 294:	f5 0a       	sbc	r15, r21
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 296:	e0 91 86 02 	lds	r30, 0x0286	; 0x800286 <__data_end>
 29a:	f0 91 87 02 	lds	r31, 0x0287	; 0x800287 <__data_end+0x1>
 29e:	02 80       	ldd	r0, Z+2	; 0x02
 2a0:	f3 81       	ldd	r31, Z+3	; 0x03
 2a2:	e0 2d       	mov	r30, r0
 2a4:	42 e1       	ldi	r20, 0x12	; 18
 2a6:	50 e0       	ldi	r21, 0x00	; 0
 2a8:	62 e5       	ldi	r22, 0x52	; 82
 2aa:	72 e0       	ldi	r23, 0x02	; 2
 2ac:	86 e8       	ldi	r24, 0x86	; 134
 2ae:	92 e0       	ldi	r25, 0x02	; 2
 2b0:	09 95       	icall

  //
  Serial.write("Elapsed time(us): ");
  Serial.println(elapsedTime);
 2b2:	2a e0       	ldi	r18, 0x0A	; 10
 2b4:	30 e0       	ldi	r19, 0x00	; 0
 2b6:	b7 01       	movw	r22, r14
 2b8:	a6 01       	movw	r20, r12
 2ba:	86 e8       	ldi	r24, 0x86	; 134
 2bc:	92 e0       	ldi	r25, 0x02	; 2
 2be:	0e 94 1c 04 	call	0x838	; 0x838 <_ZN5Print7printlnEmi>
 2c2:	8e 01       	movw	r16, r28
 2c4:	0f 5f       	subi	r16, 0xFF	; 255
 2c6:	1f 4f       	sbci	r17, 0xFF	; 255
 2c8:	7e 01       	movw	r14, r28
 2ca:	3b e5       	ldi	r19, 0x5B	; 91
 2cc:	e3 1a       	sub	r14, r19
 2ce:	3d ef       	ldi	r19, 0xFD	; 253
 2d0:	f3 0a       	sbc	r15, r19
 2d2:	68 01       	movw	r12, r16
 2d4:	44 e3       	ldi	r20, 0x34	; 52
 2d6:	c4 0e       	add	r12, r20
 2d8:	d1 1c       	adc	r13, r1
    int value = 0;
    for(int p=0; p<13; p++)
    {
	    for (int j = 0; j < 13; j++)
	    {
		    Serial.print(matrixR[value]);
 2da:	d8 01       	movw	r26, r16
 2dc:	4d 91       	ld	r20, X+
 2de:	5d 91       	ld	r21, X+
 2e0:	6d 91       	ld	r22, X+
 2e2:	7d 91       	ld	r23, X+
 2e4:	8d 01       	movw	r16, r26
 2e6:	2a e0       	ldi	r18, 0x0A	; 10
 2e8:	30 e0       	ldi	r19, 0x00	; 0
 2ea:	86 e8       	ldi	r24, 0x86	; 134
 2ec:	92 e0       	ldi	r25, 0x02	; 2
 2ee:	0e 94 2e 04 	call	0x85c	; 0x85c <_ZN5Print5printEli>
			Serial.print('\t');
 2f2:	69 e0       	ldi	r22, 0x09	; 9
 2f4:	86 e8       	ldi	r24, 0x86	; 134
 2f6:	92 e0       	ldi	r25, 0x02	; 2
 2f8:	0e 94 bb 03 	call	0x776	; 0x776 <_ZN5Print5printEc>
  
  
    int value = 0;
    for(int p=0; p<13; p++)
    {
	    for (int j = 0; j < 13; j++)
 2fc:	0c 15       	cp	r16, r12
 2fe:	1d 05       	cpc	r17, r13
 300:	61 f7       	brne	.-40     	; 0x2da <loop+0x208>
	    {
		    Serial.print(matrixR[value]);
			Serial.print('\t');
		    value++;
	    }
	    Serial.print('\n');
 302:	6a e0       	ldi	r22, 0x0A	; 10
 304:	86 e8       	ldi	r24, 0x86	; 134
 306:	92 e0       	ldi	r25, 0x02	; 2
 308:	0e 94 bb 03 	call	0x776	; 0x776 <_ZN5Print5printEc>
 30c:	86 01       	movw	r16, r12
  Serial.write("Elapsed time(us): ");
  Serial.println(elapsedTime);
  
  
    int value = 0;
    for(int p=0; p<13; p++)
 30e:	ce 14       	cp	r12, r14
 310:	df 04       	cpc	r13, r15
 312:	f9 f6       	brne	.-66     	; 0x2d2 <loop+0x200>
			Serial.print('\t');
		    value++;
	    }
	    Serial.print('\n');
    }
}
 314:	c4 55       	subi	r28, 0x54	; 84
 316:	dd 4f       	sbci	r29, 0xFD	; 253
 318:	0f b6       	in	r0, 0x3f	; 63
 31a:	f8 94       	cli
 31c:	de bf       	out	0x3e, r29	; 62
 31e:	0f be       	out	0x3f, r0	; 63
 320:	cd bf       	out	0x3d, r28	; 61
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28
 326:	1f 91       	pop	r17
 328:	0f 91       	pop	r16
 32a:	ff 90       	pop	r15
 32c:	ef 90       	pop	r14
 32e:	df 90       	pop	r13
 330:	cf 90       	pop	r12
 332:	bf 90       	pop	r11
 334:	af 90       	pop	r10
 336:	9f 90       	pop	r9
 338:	8f 90       	pop	r8
 33a:	7f 90       	pop	r7
 33c:	6f 90       	pop	r6
 33e:	5f 90       	pop	r5
 340:	4f 90       	pop	r4
 342:	3f 90       	pop	r3
 344:	08 95       	ret

00000346 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 346:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 348:	91 8d       	ldd	r25, Z+25	; 0x19
 34a:	22 8d       	ldd	r18, Z+26	; 0x1a
 34c:	89 2f       	mov	r24, r25
 34e:	90 e0       	ldi	r25, 0x00	; 0
 350:	80 5c       	subi	r24, 0xC0	; 192
 352:	9f 4f       	sbci	r25, 0xFF	; 255
 354:	82 1b       	sub	r24, r18
 356:	91 09       	sbc	r25, r1
}
 358:	8f 73       	andi	r24, 0x3F	; 63
 35a:	99 27       	eor	r25, r25
 35c:	08 95       	ret

0000035e <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
 35e:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
 360:	91 8d       	ldd	r25, Z+25	; 0x19
 362:	82 8d       	ldd	r24, Z+26	; 0x1a
 364:	98 17       	cp	r25, r24
 366:	31 f0       	breq	.+12     	; 0x374 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 368:	82 8d       	ldd	r24, Z+26	; 0x1a
 36a:	e8 0f       	add	r30, r24
 36c:	f1 1d       	adc	r31, r1
 36e:	85 8d       	ldd	r24, Z+29	; 0x1d
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 374:	8f ef       	ldi	r24, 0xFF	; 255
 376:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 378:	08 95       	ret

0000037a <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
 37a:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 37c:	91 8d       	ldd	r25, Z+25	; 0x19
 37e:	82 8d       	ldd	r24, Z+26	; 0x1a
 380:	98 17       	cp	r25, r24
 382:	61 f0       	breq	.+24     	; 0x39c <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 384:	82 8d       	ldd	r24, Z+26	; 0x1a
 386:	df 01       	movw	r26, r30
 388:	a8 0f       	add	r26, r24
 38a:	b1 1d       	adc	r27, r1
 38c:	5d 96       	adiw	r26, 0x1d	; 29
 38e:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 390:	92 8d       	ldd	r25, Z+26	; 0x1a
 392:	9f 5f       	subi	r25, 0xFF	; 255
 394:	9f 73       	andi	r25, 0x3F	; 63
 396:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
 398:	90 e0       	ldi	r25, 0x00	; 0
 39a:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 39c:	8f ef       	ldi	r24, 0xFF	; 255
 39e:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 3a0:	08 95       	ret

000003a2 <_ZN14HardwareSerial17availableForWriteEv>:
{
#if (SERIAL_TX_BUFFER_SIZE>256)
  uint8_t oldSREG = SREG;
  cli();
#endif
  tx_buffer_index_t head = _tx_buffer_head;
 3a2:	fc 01       	movw	r30, r24
 3a4:	53 8d       	ldd	r21, Z+27	; 0x1b
  tx_buffer_index_t tail = _tx_buffer_tail;
 3a6:	44 8d       	ldd	r20, Z+28	; 0x1c
 3a8:	25 2f       	mov	r18, r21
 3aa:	30 e0       	ldi	r19, 0x00	; 0
 3ac:	84 2f       	mov	r24, r20
 3ae:	90 e0       	ldi	r25, 0x00	; 0
#if (SERIAL_TX_BUFFER_SIZE>256)
  SREG = oldSREG;
#endif
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 3b0:	82 1b       	sub	r24, r18
 3b2:	93 0b       	sbc	r25, r19
 3b4:	54 17       	cp	r21, r20
 3b6:	10 f0       	brcs	.+4      	; 0x3bc <_ZN14HardwareSerial17availableForWriteEv+0x1a>
 3b8:	cf 96       	adiw	r24, 0x3f	; 63
 3ba:	08 95       	ret
  return tail - head - 1;
 3bc:	01 97       	sbiw	r24, 0x01	; 1
}
 3be:	08 95       	ret

000003c0 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 3c0:	85 e3       	ldi	r24, 0x35	; 53
 3c2:	93 e0       	ldi	r25, 0x03	; 3
 3c4:	89 2b       	or	r24, r25
 3c6:	49 f0       	breq	.+18     	; 0x3da <_Z14serialEventRunv+0x1a>
 3c8:	80 e0       	ldi	r24, 0x00	; 0
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	89 2b       	or	r24, r25
 3ce:	29 f0       	breq	.+10     	; 0x3da <_Z14serialEventRunv+0x1a>
 3d0:	0e 94 35 03 	call	0x66a	; 0x66a <_Z17Serial0_availablev>
 3d4:	81 11       	cpse	r24, r1
 3d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
 3da:	08 95       	ret

000003dc <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 3dc:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 3de:	84 8d       	ldd	r24, Z+28	; 0x1c
 3e0:	df 01       	movw	r26, r30
 3e2:	a8 0f       	add	r26, r24
 3e4:	b1 1d       	adc	r27, r1
 3e6:	a3 5a       	subi	r26, 0xA3	; 163
 3e8:	bf 4f       	sbci	r27, 0xFF	; 255
 3ea:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 3ec:	84 8d       	ldd	r24, Z+28	; 0x1c
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	01 96       	adiw	r24, 0x01	; 1
 3f2:	8f 73       	andi	r24, 0x3F	; 63
 3f4:	99 27       	eor	r25, r25
 3f6:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
 3f8:	a6 89       	ldd	r26, Z+22	; 0x16
 3fa:	b7 89       	ldd	r27, Z+23	; 0x17
 3fc:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
 3fe:	a0 89       	ldd	r26, Z+16	; 0x10
 400:	b1 89       	ldd	r27, Z+17	; 0x11
 402:	8c 91       	ld	r24, X
 404:	80 64       	ori	r24, 0x40	; 64
 406:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
 408:	93 8d       	ldd	r25, Z+27	; 0x1b
 40a:	84 8d       	ldd	r24, Z+28	; 0x1c
 40c:	98 13       	cpse	r25, r24
 40e:	06 c0       	rjmp	.+12     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 410:	02 88       	ldd	r0, Z+18	; 0x12
 412:	f3 89       	ldd	r31, Z+19	; 0x13
 414:	e0 2d       	mov	r30, r0
 416:	80 81       	ld	r24, Z
 418:	8f 7d       	andi	r24, 0xDF	; 223
 41a:	80 83       	st	Z, r24
 41c:	08 95       	ret

0000041e <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 41e:	ef 92       	push	r14
 420:	ff 92       	push	r15
 422:	0f 93       	push	r16
 424:	1f 93       	push	r17
 426:	cf 93       	push	r28
 428:	df 93       	push	r29
 42a:	ec 01       	movw	r28, r24
  _written = true;
 42c:	81 e0       	ldi	r24, 0x01	; 1
 42e:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 430:	9b 8d       	ldd	r25, Y+27	; 0x1b
 432:	8c 8d       	ldd	r24, Y+28	; 0x1c
 434:	98 13       	cpse	r25, r24
 436:	05 c0       	rjmp	.+10     	; 0x442 <_ZN14HardwareSerial5writeEh+0x24>
 438:	e8 89       	ldd	r30, Y+16	; 0x10
 43a:	f9 89       	ldd	r31, Y+17	; 0x11
 43c:	80 81       	ld	r24, Z
 43e:	85 fd       	sbrc	r24, 5
 440:	24 c0       	rjmp	.+72     	; 0x48a <_ZN14HardwareSerial5writeEh+0x6c>
 442:	f6 2e       	mov	r15, r22
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 444:	0b 8d       	ldd	r16, Y+27	; 0x1b
 446:	10 e0       	ldi	r17, 0x00	; 0
 448:	0f 5f       	subi	r16, 0xFF	; 255
 44a:	1f 4f       	sbci	r17, 0xFF	; 255
 44c:	0f 73       	andi	r16, 0x3F	; 63
 44e:	11 27       	eor	r17, r17
 450:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 452:	8c 8d       	ldd	r24, Y+28	; 0x1c
 454:	e8 12       	cpse	r14, r24
 456:	0c c0       	rjmp	.+24     	; 0x470 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
 458:	0f b6       	in	r0, 0x3f	; 63
 45a:	07 fc       	sbrc	r0, 7
 45c:	fa cf       	rjmp	.-12     	; 0x452 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 45e:	e8 89       	ldd	r30, Y+16	; 0x10
 460:	f9 89       	ldd	r31, Y+17	; 0x11
 462:	80 81       	ld	r24, Z
 464:	85 ff       	sbrs	r24, 5
 466:	f5 cf       	rjmp	.-22     	; 0x452 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
 468:	ce 01       	movw	r24, r28
 46a:	0e 94 ee 01 	call	0x3dc	; 0x3dc <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 46e:	f1 cf       	rjmp	.-30     	; 0x452 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 470:	8b 8d       	ldd	r24, Y+27	; 0x1b
 472:	fe 01       	movw	r30, r28
 474:	e8 0f       	add	r30, r24
 476:	f1 1d       	adc	r31, r1
 478:	e3 5a       	subi	r30, 0xA3	; 163
 47a:	ff 4f       	sbci	r31, 0xFF	; 255
 47c:	f0 82       	st	Z, r15
  _tx_buffer_head = i;
 47e:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
 480:	ea 89       	ldd	r30, Y+18	; 0x12
 482:	fb 89       	ldd	r31, Y+19	; 0x13
 484:	80 81       	ld	r24, Z
 486:	80 62       	ori	r24, 0x20	; 32
 488:	07 c0       	rjmp	.+14     	; 0x498 <_ZN14HardwareSerial5writeEh+0x7a>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
 48a:	ee 89       	ldd	r30, Y+22	; 0x16
 48c:	ff 89       	ldd	r31, Y+23	; 0x17
 48e:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
 490:	e8 89       	ldd	r30, Y+16	; 0x10
 492:	f9 89       	ldd	r31, Y+17	; 0x11
 494:	80 81       	ld	r24, Z
 496:	80 64       	ori	r24, 0x40	; 64
 498:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
 49a:	81 e0       	ldi	r24, 0x01	; 1
 49c:	90 e0       	ldi	r25, 0x00	; 0
 49e:	df 91       	pop	r29
 4a0:	cf 91       	pop	r28
 4a2:	1f 91       	pop	r17
 4a4:	0f 91       	pop	r16
 4a6:	ff 90       	pop	r15
 4a8:	ef 90       	pop	r14
 4aa:	08 95       	ret

000004ac <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 4ac:	cf 93       	push	r28
 4ae:	df 93       	push	r29
 4b0:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 4b2:	88 8d       	ldd	r24, Y+24	; 0x18
 4b4:	88 23       	and	r24, r24
 4b6:	c9 f0       	breq	.+50     	; 0x4ea <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 4b8:	ea 89       	ldd	r30, Y+18	; 0x12
 4ba:	fb 89       	ldd	r31, Y+19	; 0x13
 4bc:	80 81       	ld	r24, Z
 4be:	85 fd       	sbrc	r24, 5
 4c0:	05 c0       	rjmp	.+10     	; 0x4cc <_ZN14HardwareSerial5flushEv+0x20>
 4c2:	a8 89       	ldd	r26, Y+16	; 0x10
 4c4:	b9 89       	ldd	r27, Y+17	; 0x11
 4c6:	8c 91       	ld	r24, X
 4c8:	86 fd       	sbrc	r24, 6
 4ca:	0f c0       	rjmp	.+30     	; 0x4ea <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 4cc:	0f b6       	in	r0, 0x3f	; 63
 4ce:	07 fc       	sbrc	r0, 7
 4d0:	f5 cf       	rjmp	.-22     	; 0x4bc <_ZN14HardwareSerial5flushEv+0x10>
 4d2:	80 81       	ld	r24, Z
 4d4:	85 ff       	sbrs	r24, 5
 4d6:	f2 cf       	rjmp	.-28     	; 0x4bc <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 4d8:	a8 89       	ldd	r26, Y+16	; 0x10
 4da:	b9 89       	ldd	r27, Y+17	; 0x11
 4dc:	8c 91       	ld	r24, X
 4de:	85 ff       	sbrs	r24, 5
 4e0:	ed cf       	rjmp	.-38     	; 0x4bc <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
 4e2:	ce 01       	movw	r24, r28
 4e4:	0e 94 ee 01 	call	0x3dc	; 0x3dc <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 4e8:	e7 cf       	rjmp	.-50     	; 0x4b8 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 4ea:	df 91       	pop	r29
 4ec:	cf 91       	pop	r28
 4ee:	08 95       	ret

000004f0 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
 4f0:	cf 92       	push	r12
 4f2:	df 92       	push	r13
 4f4:	ef 92       	push	r14
 4f6:	ff 92       	push	r15
 4f8:	1f 93       	push	r17
 4fa:	cf 93       	push	r28
 4fc:	df 93       	push	r29
 4fe:	ec 01       	movw	r28, r24
 500:	6a 01       	movw	r12, r20
 502:	7b 01       	movw	r14, r22
 504:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 506:	e8 89       	ldd	r30, Y+16	; 0x10
 508:	f9 89       	ldd	r31, Y+17	; 0x11
 50a:	82 e0       	ldi	r24, 0x02	; 2
 50c:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
 50e:	41 15       	cp	r20, r1
 510:	51 4e       	sbci	r21, 0xE1	; 225
 512:	61 05       	cpc	r22, r1
 514:	71 05       	cpc	r23, r1
 516:	b1 f0       	breq	.+44     	; 0x544 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
 518:	60 e0       	ldi	r22, 0x00	; 0
 51a:	79 e0       	ldi	r23, 0x09	; 9
 51c:	8d e3       	ldi	r24, 0x3D	; 61
 51e:	90 e0       	ldi	r25, 0x00	; 0
 520:	a7 01       	movw	r20, r14
 522:	96 01       	movw	r18, r12
 524:	0e 94 20 05 	call	0xa40	; 0xa40 <__udivmodsi4>
 528:	da 01       	movw	r26, r20
 52a:	c9 01       	movw	r24, r18
 52c:	01 97       	sbiw	r24, 0x01	; 1
 52e:	a1 09       	sbc	r26, r1
 530:	b1 09       	sbc	r27, r1
 532:	b6 95       	lsr	r27
 534:	a7 95       	ror	r26
 536:	97 95       	ror	r25
 538:	87 95       	ror	r24
 53a:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
 53c:	21 15       	cp	r18, r1
 53e:	80 e1       	ldi	r24, 0x10	; 16
 540:	38 07       	cpc	r19, r24
 542:	a8 f0       	brcs	.+42     	; 0x56e <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
 544:	e8 89       	ldd	r30, Y+16	; 0x10
 546:	f9 89       	ldd	r31, Y+17	; 0x11
 548:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
 54a:	60 e8       	ldi	r22, 0x80	; 128
 54c:	74 e8       	ldi	r23, 0x84	; 132
 54e:	8e e1       	ldi	r24, 0x1E	; 30
 550:	90 e0       	ldi	r25, 0x00	; 0
 552:	a7 01       	movw	r20, r14
 554:	96 01       	movw	r18, r12
 556:	0e 94 20 05 	call	0xa40	; 0xa40 <__udivmodsi4>
 55a:	da 01       	movw	r26, r20
 55c:	c9 01       	movw	r24, r18
 55e:	01 97       	sbiw	r24, 0x01	; 1
 560:	a1 09       	sbc	r26, r1
 562:	b1 09       	sbc	r27, r1
 564:	b6 95       	lsr	r27
 566:	a7 95       	ror	r26
 568:	97 95       	ror	r25
 56a:	87 95       	ror	r24
 56c:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 56e:	ec 85       	ldd	r30, Y+12	; 0x0c
 570:	fd 85       	ldd	r31, Y+13	; 0x0d
 572:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
 574:	ee 85       	ldd	r30, Y+14	; 0x0e
 576:	ff 85       	ldd	r31, Y+15	; 0x0f
 578:	20 83       	st	Z, r18

  _written = false;
 57a:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 57c:	ec 89       	ldd	r30, Y+20	; 0x14
 57e:	fd 89       	ldd	r31, Y+21	; 0x15
 580:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
 582:	ea 89       	ldd	r30, Y+18	; 0x12
 584:	fb 89       	ldd	r31, Y+19	; 0x13
 586:	80 81       	ld	r24, Z
 588:	80 61       	ori	r24, 0x10	; 16
 58a:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
 58c:	ea 89       	ldd	r30, Y+18	; 0x12
 58e:	fb 89       	ldd	r31, Y+19	; 0x13
 590:	80 81       	ld	r24, Z
 592:	88 60       	ori	r24, 0x08	; 8
 594:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
 596:	ea 89       	ldd	r30, Y+18	; 0x12
 598:	fb 89       	ldd	r31, Y+19	; 0x13
 59a:	80 81       	ld	r24, Z
 59c:	80 68       	ori	r24, 0x80	; 128
 59e:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
 5a0:	ea 89       	ldd	r30, Y+18	; 0x12
 5a2:	fb 89       	ldd	r31, Y+19	; 0x13
 5a4:	80 81       	ld	r24, Z
 5a6:	8f 7d       	andi	r24, 0xDF	; 223
 5a8:	80 83       	st	Z, r24
}
 5aa:	df 91       	pop	r29
 5ac:	cf 91       	pop	r28
 5ae:	1f 91       	pop	r17
 5b0:	ff 90       	pop	r15
 5b2:	ef 90       	pop	r14
 5b4:	df 90       	pop	r13
 5b6:	cf 90       	pop	r12
 5b8:	08 95       	ret

000005ba <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 5ba:	1f 92       	push	r1
 5bc:	0f 92       	push	r0
 5be:	0f b6       	in	r0, 0x3f	; 63
 5c0:	0f 92       	push	r0
 5c2:	11 24       	eor	r1, r1
 5c4:	2f 93       	push	r18
 5c6:	8f 93       	push	r24
 5c8:	9f 93       	push	r25
 5ca:	ef 93       	push	r30
 5cc:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 5ce:	e0 91 96 02 	lds	r30, 0x0296	; 0x800296 <__data_end+0x10>
 5d2:	f0 91 97 02 	lds	r31, 0x0297	; 0x800297 <__data_end+0x11>
 5d6:	80 81       	ld	r24, Z
 5d8:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end+0x16>
 5dc:	f0 91 9d 02 	lds	r31, 0x029D	; 0x80029d <__data_end+0x17>
 5e0:	82 fd       	sbrc	r24, 2
 5e2:	12 c0       	rjmp	.+36     	; 0x608 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 5e4:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 5e6:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <__data_end+0x19>
 5ea:	8f 5f       	subi	r24, 0xFF	; 255
 5ec:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 5ee:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <__data_end+0x1a>
 5f2:	82 17       	cp	r24, r18
 5f4:	51 f0       	breq	.+20     	; 0x60a <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
 5f6:	e0 91 9f 02 	lds	r30, 0x029F	; 0x80029f <__data_end+0x19>
 5fa:	f0 e0       	ldi	r31, 0x00	; 0
 5fc:	ea 57       	subi	r30, 0x7A	; 122
 5fe:	fd 4f       	sbci	r31, 0xFD	; 253
 600:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
 602:	80 93 9f 02 	sts	0x029F, r24	; 0x80029f <__data_end+0x19>
 606:	01 c0       	rjmp	.+2      	; 0x60a <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 608:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
 60a:	ff 91       	pop	r31
 60c:	ef 91       	pop	r30
 60e:	9f 91       	pop	r25
 610:	8f 91       	pop	r24
 612:	2f 91       	pop	r18
 614:	0f 90       	pop	r0
 616:	0f be       	out	0x3f, r0	; 63
 618:	0f 90       	pop	r0
 61a:	1f 90       	pop	r1
 61c:	18 95       	reti

0000061e <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 61e:	1f 92       	push	r1
 620:	0f 92       	push	r0
 622:	0f b6       	in	r0, 0x3f	; 63
 624:	0f 92       	push	r0
 626:	11 24       	eor	r1, r1
 628:	2f 93       	push	r18
 62a:	3f 93       	push	r19
 62c:	4f 93       	push	r20
 62e:	5f 93       	push	r21
 630:	6f 93       	push	r22
 632:	7f 93       	push	r23
 634:	8f 93       	push	r24
 636:	9f 93       	push	r25
 638:	af 93       	push	r26
 63a:	bf 93       	push	r27
 63c:	ef 93       	push	r30
 63e:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
 640:	86 e8       	ldi	r24, 0x86	; 134
 642:	92 e0       	ldi	r25, 0x02	; 2
 644:	0e 94 ee 01 	call	0x3dc	; 0x3dc <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
 648:	ff 91       	pop	r31
 64a:	ef 91       	pop	r30
 64c:	bf 91       	pop	r27
 64e:	af 91       	pop	r26
 650:	9f 91       	pop	r25
 652:	8f 91       	pop	r24
 654:	7f 91       	pop	r23
 656:	6f 91       	pop	r22
 658:	5f 91       	pop	r21
 65a:	4f 91       	pop	r20
 65c:	3f 91       	pop	r19
 65e:	2f 91       	pop	r18
 660:	0f 90       	pop	r0
 662:	0f be       	out	0x3f, r0	; 63
 664:	0f 90       	pop	r0
 666:	1f 90       	pop	r1
 668:	18 95       	reti

0000066a <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 66a:	86 e8       	ldi	r24, 0x86	; 134
 66c:	92 e0       	ldi	r25, 0x02	; 2
 66e:	0e 94 a3 01 	call	0x346	; 0x346 <_ZN14HardwareSerial9availableEv>
 672:	21 e0       	ldi	r18, 0x01	; 1
 674:	89 2b       	or	r24, r25
 676:	09 f4       	brne	.+2      	; 0x67a <_Z17Serial0_availablev+0x10>
 678:	20 e0       	ldi	r18, 0x00	; 0
}
 67a:	82 2f       	mov	r24, r18
 67c:	08 95       	ret

0000067e <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 67e:	e6 e8       	ldi	r30, 0x86	; 134
 680:	f2 e0       	ldi	r31, 0x02	; 2
 682:	13 82       	std	Z+3, r1	; 0x03
 684:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
 686:	88 ee       	ldi	r24, 0xE8	; 232
 688:	93 e0       	ldi	r25, 0x03	; 3
 68a:	a0 e0       	ldi	r26, 0x00	; 0
 68c:	b0 e0       	ldi	r27, 0x00	; 0
 68e:	84 83       	std	Z+4, r24	; 0x04
 690:	95 83       	std	Z+5, r25	; 0x05
 692:	a6 83       	std	Z+6, r26	; 0x06
 694:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 696:	89 e6       	ldi	r24, 0x69	; 105
 698:	92 e0       	ldi	r25, 0x02	; 2
 69a:	91 83       	std	Z+1, r25	; 0x01
 69c:	80 83       	st	Z, r24
 69e:	85 ec       	ldi	r24, 0xC5	; 197
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	95 87       	std	Z+13, r25	; 0x0d
 6a4:	84 87       	std	Z+12, r24	; 0x0c
 6a6:	84 ec       	ldi	r24, 0xC4	; 196
 6a8:	90 e0       	ldi	r25, 0x00	; 0
 6aa:	97 87       	std	Z+15, r25	; 0x0f
 6ac:	86 87       	std	Z+14, r24	; 0x0e
 6ae:	80 ec       	ldi	r24, 0xC0	; 192
 6b0:	90 e0       	ldi	r25, 0x00	; 0
 6b2:	91 8b       	std	Z+17, r25	; 0x11
 6b4:	80 8b       	std	Z+16, r24	; 0x10
 6b6:	81 ec       	ldi	r24, 0xC1	; 193
 6b8:	90 e0       	ldi	r25, 0x00	; 0
 6ba:	93 8b       	std	Z+19, r25	; 0x13
 6bc:	82 8b       	std	Z+18, r24	; 0x12
 6be:	82 ec       	ldi	r24, 0xC2	; 194
 6c0:	90 e0       	ldi	r25, 0x00	; 0
 6c2:	95 8b       	std	Z+21, r25	; 0x15
 6c4:	84 8b       	std	Z+20, r24	; 0x14
 6c6:	86 ec       	ldi	r24, 0xC6	; 198
 6c8:	90 e0       	ldi	r25, 0x00	; 0
 6ca:	97 8b       	std	Z+23, r25	; 0x17
 6cc:	86 8b       	std	Z+22, r24	; 0x16
 6ce:	11 8e       	std	Z+25, r1	; 0x19
 6d0:	12 8e       	std	Z+26, r1	; 0x1a
 6d2:	13 8e       	std	Z+27, r1	; 0x1b
 6d4:	14 8e       	std	Z+28, r1	; 0x1c
 6d6:	08 95       	ret

000006d8 <initVariant>:
 6d8:	08 95       	ret

000006da <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
 6da:	0e 94 e5 04 	call	0x9ca	; 0x9ca <init>

	initVariant();
 6de:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 6e2:	0e 94 5f 00 	call	0xbe	; 0xbe <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 6e6:	c0 ee       	ldi	r28, 0xE0	; 224
 6e8:	d1 e0       	ldi	r29, 0x01	; 1
#endif
	
	setup();
    
	for (;;) {
		loop();
 6ea:	0e 94 69 00 	call	0xd2	; 0xd2 <loop>
		if (serialEventRun) serialEventRun();
 6ee:	20 97       	sbiw	r28, 0x00	; 0
 6f0:	e1 f3       	breq	.-8      	; 0x6ea <main+0x10>
 6f2:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <_Z14serialEventRunv>
 6f6:	f9 cf       	rjmp	.-14     	; 0x6ea <main+0x10>

000006f8 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
 6f8:	cf 92       	push	r12
 6fa:	df 92       	push	r13
 6fc:	ef 92       	push	r14
 6fe:	ff 92       	push	r15
 700:	0f 93       	push	r16
 702:	1f 93       	push	r17
 704:	cf 93       	push	r28
 706:	df 93       	push	r29
 708:	6c 01       	movw	r12, r24
 70a:	7a 01       	movw	r14, r20
 70c:	8b 01       	movw	r16, r22
 70e:	c0 e0       	ldi	r28, 0x00	; 0
 710:	d0 e0       	ldi	r29, 0x00	; 0
 712:	ce 15       	cp	r28, r14
 714:	df 05       	cpc	r29, r15
 716:	81 f0       	breq	.+32     	; 0x738 <_ZN5Print5writeEPKhj+0x40>
 718:	d8 01       	movw	r26, r16
 71a:	6d 91       	ld	r22, X+
 71c:	8d 01       	movw	r16, r26
 71e:	d6 01       	movw	r26, r12
 720:	ed 91       	ld	r30, X+
 722:	fc 91       	ld	r31, X
 724:	01 90       	ld	r0, Z+
 726:	f0 81       	ld	r31, Z
 728:	e0 2d       	mov	r30, r0
 72a:	c6 01       	movw	r24, r12
 72c:	09 95       	icall
 72e:	89 2b       	or	r24, r25
 730:	11 f0       	breq	.+4      	; 0x736 <_ZN5Print5writeEPKhj+0x3e>
 732:	21 96       	adiw	r28, 0x01	; 1
 734:	ee cf       	rjmp	.-36     	; 0x712 <_ZN5Print5writeEPKhj+0x1a>
 736:	7e 01       	movw	r14, r28
 738:	c7 01       	movw	r24, r14
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	1f 91       	pop	r17
 740:	0f 91       	pop	r16
 742:	ff 90       	pop	r15
 744:	ef 90       	pop	r14
 746:	df 90       	pop	r13
 748:	cf 90       	pop	r12
 74a:	08 95       	ret

0000074c <_ZN5Print5writeEPKc>:
 74c:	61 15       	cp	r22, r1
 74e:	71 05       	cpc	r23, r1
 750:	79 f0       	breq	.+30     	; 0x770 <_ZN5Print5writeEPKc+0x24>
 752:	fb 01       	movw	r30, r22
 754:	01 90       	ld	r0, Z+
 756:	00 20       	and	r0, r0
 758:	e9 f7       	brne	.-6      	; 0x754 <_ZN5Print5writeEPKc+0x8>
 75a:	31 97       	sbiw	r30, 0x01	; 1
 75c:	af 01       	movw	r20, r30
 75e:	46 1b       	sub	r20, r22
 760:	57 0b       	sbc	r21, r23
 762:	dc 01       	movw	r26, r24
 764:	ed 91       	ld	r30, X+
 766:	fc 91       	ld	r31, X
 768:	02 80       	ldd	r0, Z+2	; 0x02
 76a:	f3 81       	ldd	r31, Z+3	; 0x03
 76c:	e0 2d       	mov	r30, r0
 76e:	09 94       	ijmp
 770:	80 e0       	ldi	r24, 0x00	; 0
 772:	90 e0       	ldi	r25, 0x00	; 0
 774:	08 95       	ret

00000776 <_ZN5Print5printEc>:
 776:	dc 01       	movw	r26, r24
 778:	ed 91       	ld	r30, X+
 77a:	fc 91       	ld	r31, X
 77c:	01 90       	ld	r0, Z+
 77e:	f0 81       	ld	r31, Z
 780:	e0 2d       	mov	r30, r0
 782:	09 94       	ijmp

00000784 <_ZN5Print7printlnEv>:
 784:	67 e7       	ldi	r22, 0x77	; 119
 786:	72 e0       	ldi	r23, 0x02	; 2
 788:	0c 94 a6 03 	jmp	0x74c	; 0x74c <_ZN5Print5writeEPKc>

0000078c <_ZN5Print11printNumberEmh>:
 78c:	8f 92       	push	r8
 78e:	9f 92       	push	r9
 790:	af 92       	push	r10
 792:	bf 92       	push	r11
 794:	ef 92       	push	r14
 796:	ff 92       	push	r15
 798:	0f 93       	push	r16
 79a:	1f 93       	push	r17
 79c:	cf 93       	push	r28
 79e:	df 93       	push	r29
 7a0:	cd b7       	in	r28, 0x3d	; 61
 7a2:	de b7       	in	r29, 0x3e	; 62
 7a4:	a1 97       	sbiw	r28, 0x21	; 33
 7a6:	0f b6       	in	r0, 0x3f	; 63
 7a8:	f8 94       	cli
 7aa:	de bf       	out	0x3e, r29	; 62
 7ac:	0f be       	out	0x3f, r0	; 63
 7ae:	cd bf       	out	0x3d, r28	; 61
 7b0:	7c 01       	movw	r14, r24
 7b2:	fa 01       	movw	r30, r20
 7b4:	cb 01       	movw	r24, r22
 7b6:	19 a2       	std	Y+33, r1	; 0x21
 7b8:	22 30       	cpi	r18, 0x02	; 2
 7ba:	08 f4       	brcc	.+2      	; 0x7be <_ZN5Print11printNumberEmh+0x32>
 7bc:	2a e0       	ldi	r18, 0x0A	; 10
 7be:	8e 01       	movw	r16, r28
 7c0:	0f 5d       	subi	r16, 0xDF	; 223
 7c2:	1f 4f       	sbci	r17, 0xFF	; 255
 7c4:	82 2e       	mov	r8, r18
 7c6:	91 2c       	mov	r9, r1
 7c8:	a1 2c       	mov	r10, r1
 7ca:	b1 2c       	mov	r11, r1
 7cc:	bf 01       	movw	r22, r30
 7ce:	a5 01       	movw	r20, r10
 7d0:	94 01       	movw	r18, r8
 7d2:	0e 94 20 05 	call	0xa40	; 0xa40 <__udivmodsi4>
 7d6:	f9 01       	movw	r30, r18
 7d8:	ca 01       	movw	r24, r20
 7da:	01 50       	subi	r16, 0x01	; 1
 7dc:	11 09       	sbc	r17, r1
 7de:	6a 30       	cpi	r22, 0x0A	; 10
 7e0:	10 f4       	brcc	.+4      	; 0x7e6 <_ZN5Print11printNumberEmh+0x5a>
 7e2:	60 5d       	subi	r22, 0xD0	; 208
 7e4:	01 c0       	rjmp	.+2      	; 0x7e8 <_ZN5Print11printNumberEmh+0x5c>
 7e6:	69 5c       	subi	r22, 0xC9	; 201
 7e8:	d8 01       	movw	r26, r16
 7ea:	6c 93       	st	X, r22
 7ec:	23 2b       	or	r18, r19
 7ee:	24 2b       	or	r18, r20
 7f0:	25 2b       	or	r18, r21
 7f2:	61 f7       	brne	.-40     	; 0x7cc <_ZN5Print11printNumberEmh+0x40>
 7f4:	b8 01       	movw	r22, r16
 7f6:	c7 01       	movw	r24, r14
 7f8:	0e 94 a6 03 	call	0x74c	; 0x74c <_ZN5Print5writeEPKc>
 7fc:	a1 96       	adiw	r28, 0x21	; 33
 7fe:	0f b6       	in	r0, 0x3f	; 63
 800:	f8 94       	cli
 802:	de bf       	out	0x3e, r29	; 62
 804:	0f be       	out	0x3f, r0	; 63
 806:	cd bf       	out	0x3d, r28	; 61
 808:	df 91       	pop	r29
 80a:	cf 91       	pop	r28
 80c:	1f 91       	pop	r17
 80e:	0f 91       	pop	r16
 810:	ff 90       	pop	r15
 812:	ef 90       	pop	r14
 814:	bf 90       	pop	r11
 816:	af 90       	pop	r10
 818:	9f 90       	pop	r9
 81a:	8f 90       	pop	r8
 81c:	08 95       	ret

0000081e <_ZN5Print5printEmi>:
 81e:	21 15       	cp	r18, r1
 820:	31 05       	cpc	r19, r1
 822:	41 f4       	brne	.+16     	; 0x834 <_ZN5Print5printEmi+0x16>
 824:	dc 01       	movw	r26, r24
 826:	ed 91       	ld	r30, X+
 828:	fc 91       	ld	r31, X
 82a:	01 90       	ld	r0, Z+
 82c:	f0 81       	ld	r31, Z
 82e:	e0 2d       	mov	r30, r0
 830:	64 2f       	mov	r22, r20
 832:	09 94       	ijmp
 834:	0c 94 c6 03 	jmp	0x78c	; 0x78c <_ZN5Print11printNumberEmh>

00000838 <_ZN5Print7printlnEmi>:
  n += println();
  return n;
}

size_t Print::println(unsigned long num, int base)
{
 838:	0f 93       	push	r16
 83a:	1f 93       	push	r17
 83c:	cf 93       	push	r28
 83e:	df 93       	push	r29
 840:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
 842:	0e 94 0f 04 	call	0x81e	; 0x81e <_ZN5Print5printEmi>
 846:	8c 01       	movw	r16, r24
  n += println();
 848:	ce 01       	movw	r24, r28
 84a:	0e 94 c2 03 	call	0x784	; 0x784 <_ZN5Print7printlnEv>
  return n;
}
 84e:	80 0f       	add	r24, r16
 850:	91 1f       	adc	r25, r17
 852:	df 91       	pop	r29
 854:	cf 91       	pop	r28
 856:	1f 91       	pop	r17
 858:	0f 91       	pop	r16
 85a:	08 95       	ret

0000085c <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
 85c:	cf 92       	push	r12
 85e:	df 92       	push	r13
 860:	ef 92       	push	r14
 862:	ff 92       	push	r15
 864:	0f 93       	push	r16
 866:	1f 93       	push	r17
 868:	cf 93       	push	r28
 86a:	df 93       	push	r29
  if (base == 0) {
 86c:	21 15       	cp	r18, r1
 86e:	31 05       	cpc	r19, r1
 870:	81 f4       	brne	.+32     	; 0x892 <_ZN5Print5printEli+0x36>
    return write(n);
 872:	dc 01       	movw	r26, r24
 874:	ed 91       	ld	r30, X+
 876:	fc 91       	ld	r31, X
 878:	01 90       	ld	r0, Z+
 87a:	f0 81       	ld	r31, Z
 87c:	e0 2d       	mov	r30, r0
 87e:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 880:	df 91       	pop	r29
 882:	cf 91       	pop	r28
 884:	1f 91       	pop	r17
 886:	0f 91       	pop	r16
 888:	ff 90       	pop	r15
 88a:	ef 90       	pop	r14
 88c:	df 90       	pop	r13
 88e:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
 890:	09 94       	ijmp
  } else if (base == 10) {
 892:	2a 30       	cpi	r18, 0x0A	; 10
 894:	31 05       	cpc	r19, r1
 896:	01 f5       	brne	.+64     	; 0x8d8 <_ZN5Print5printEli+0x7c>
    if (n < 0) {
 898:	77 ff       	sbrs	r23, 7
 89a:	1d c0       	rjmp	.+58     	; 0x8d6 <_ZN5Print5printEli+0x7a>
 89c:	6a 01       	movw	r12, r20
 89e:	7b 01       	movw	r14, r22
 8a0:	ec 01       	movw	r28, r24
      int t = print('-');
 8a2:	6d e2       	ldi	r22, 0x2D	; 45
 8a4:	0e 94 bb 03 	call	0x776	; 0x776 <_ZN5Print5printEc>
 8a8:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
 8aa:	44 27       	eor	r20, r20
 8ac:	55 27       	eor	r21, r21
 8ae:	ba 01       	movw	r22, r20
 8b0:	4c 19       	sub	r20, r12
 8b2:	5d 09       	sbc	r21, r13
 8b4:	6e 09       	sbc	r22, r14
 8b6:	7f 09       	sbc	r23, r15
 8b8:	2a e0       	ldi	r18, 0x0A	; 10
 8ba:	ce 01       	movw	r24, r28
 8bc:	0e 94 c6 03 	call	0x78c	; 0x78c <_ZN5Print11printNumberEmh>
 8c0:	80 0f       	add	r24, r16
 8c2:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 8c4:	df 91       	pop	r29
 8c6:	cf 91       	pop	r28
 8c8:	1f 91       	pop	r17
 8ca:	0f 91       	pop	r16
 8cc:	ff 90       	pop	r15
 8ce:	ef 90       	pop	r14
 8d0:	df 90       	pop	r13
 8d2:	cf 90       	pop	r12
 8d4:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
 8d6:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
 8d8:	df 91       	pop	r29
 8da:	cf 91       	pop	r28
 8dc:	1f 91       	pop	r17
 8de:	0f 91       	pop	r16
 8e0:	ff 90       	pop	r15
 8e2:	ef 90       	pop	r14
 8e4:	df 90       	pop	r13
 8e6:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 8e8:	0c 94 c6 03 	jmp	0x78c	; 0x78c <_ZN5Print11printNumberEmh>

000008ec <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
 8ec:	1f 92       	push	r1
 8ee:	0f 92       	push	r0
 8f0:	0f b6       	in	r0, 0x3f	; 63
 8f2:	0f 92       	push	r0
 8f4:	11 24       	eor	r1, r1
 8f6:	2f 93       	push	r18
 8f8:	3f 93       	push	r19
 8fa:	8f 93       	push	r24
 8fc:	9f 93       	push	r25
 8fe:	af 93       	push	r26
 900:	bf 93       	push	r27
 902:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <timer0_millis>
 906:	90 91 25 03 	lds	r25, 0x0325	; 0x800325 <timer0_millis+0x1>
 90a:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <timer0_millis+0x2>
 90e:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <timer0_millis+0x3>
 912:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <timer0_fract>
 916:	23 e0       	ldi	r18, 0x03	; 3
 918:	23 0f       	add	r18, r19
 91a:	2d 37       	cpi	r18, 0x7D	; 125
 91c:	20 f4       	brcc	.+8      	; 0x926 <__stack+0x27>
 91e:	01 96       	adiw	r24, 0x01	; 1
 920:	a1 1d       	adc	r26, r1
 922:	b1 1d       	adc	r27, r1
 924:	05 c0       	rjmp	.+10     	; 0x930 <__stack+0x31>
 926:	26 e8       	ldi	r18, 0x86	; 134
 928:	23 0f       	add	r18, r19
 92a:	02 96       	adiw	r24, 0x02	; 2
 92c:	a1 1d       	adc	r26, r1
 92e:	b1 1d       	adc	r27, r1
 930:	20 93 23 03 	sts	0x0323, r18	; 0x800323 <timer0_fract>
 934:	80 93 24 03 	sts	0x0324, r24	; 0x800324 <timer0_millis>
 938:	90 93 25 03 	sts	0x0325, r25	; 0x800325 <timer0_millis+0x1>
 93c:	a0 93 26 03 	sts	0x0326, r26	; 0x800326 <timer0_millis+0x2>
 940:	b0 93 27 03 	sts	0x0327, r27	; 0x800327 <timer0_millis+0x3>
 944:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <timer0_overflow_count>
 948:	90 91 29 03 	lds	r25, 0x0329	; 0x800329 <timer0_overflow_count+0x1>
 94c:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <timer0_overflow_count+0x2>
 950:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <timer0_overflow_count+0x3>
 954:	01 96       	adiw	r24, 0x01	; 1
 956:	a1 1d       	adc	r26, r1
 958:	b1 1d       	adc	r27, r1
 95a:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <timer0_overflow_count>
 95e:	90 93 29 03 	sts	0x0329, r25	; 0x800329 <timer0_overflow_count+0x1>
 962:	a0 93 2a 03 	sts	0x032A, r26	; 0x80032a <timer0_overflow_count+0x2>
 966:	b0 93 2b 03 	sts	0x032B, r27	; 0x80032b <timer0_overflow_count+0x3>
 96a:	bf 91       	pop	r27
 96c:	af 91       	pop	r26
 96e:	9f 91       	pop	r25
 970:	8f 91       	pop	r24
 972:	3f 91       	pop	r19
 974:	2f 91       	pop	r18
 976:	0f 90       	pop	r0
 978:	0f be       	out	0x3f, r0	; 63
 97a:	0f 90       	pop	r0
 97c:	1f 90       	pop	r1
 97e:	18 95       	reti

00000980 <micros>:
 980:	3f b7       	in	r19, 0x3f	; 63
 982:	f8 94       	cli
 984:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <timer0_overflow_count>
 988:	90 91 29 03 	lds	r25, 0x0329	; 0x800329 <timer0_overflow_count+0x1>
 98c:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <timer0_overflow_count+0x2>
 990:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <timer0_overflow_count+0x3>
 994:	26 b5       	in	r18, 0x26	; 38
 996:	a8 9b       	sbis	0x15, 0	; 21
 998:	05 c0       	rjmp	.+10     	; 0x9a4 <micros+0x24>
 99a:	2f 3f       	cpi	r18, 0xFF	; 255
 99c:	19 f0       	breq	.+6      	; 0x9a4 <micros+0x24>
 99e:	01 96       	adiw	r24, 0x01	; 1
 9a0:	a1 1d       	adc	r26, r1
 9a2:	b1 1d       	adc	r27, r1
 9a4:	3f bf       	out	0x3f, r19	; 63
 9a6:	ba 2f       	mov	r27, r26
 9a8:	a9 2f       	mov	r26, r25
 9aa:	98 2f       	mov	r25, r24
 9ac:	88 27       	eor	r24, r24
 9ae:	82 0f       	add	r24, r18
 9b0:	91 1d       	adc	r25, r1
 9b2:	a1 1d       	adc	r26, r1
 9b4:	b1 1d       	adc	r27, r1
 9b6:	bc 01       	movw	r22, r24
 9b8:	cd 01       	movw	r24, r26
 9ba:	42 e0       	ldi	r20, 0x02	; 2
 9bc:	66 0f       	add	r22, r22
 9be:	77 1f       	adc	r23, r23
 9c0:	88 1f       	adc	r24, r24
 9c2:	99 1f       	adc	r25, r25
 9c4:	4a 95       	dec	r20
 9c6:	d1 f7       	brne	.-12     	; 0x9bc <micros+0x3c>
 9c8:	08 95       	ret

000009ca <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 9ca:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 9cc:	84 b5       	in	r24, 0x24	; 36
 9ce:	82 60       	ori	r24, 0x02	; 2
 9d0:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 9d2:	84 b5       	in	r24, 0x24	; 36
 9d4:	81 60       	ori	r24, 0x01	; 1
 9d6:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 9d8:	85 b5       	in	r24, 0x25	; 37
 9da:	82 60       	ori	r24, 0x02	; 2
 9dc:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 9de:	85 b5       	in	r24, 0x25	; 37
 9e0:	81 60       	ori	r24, 0x01	; 1
 9e2:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 9e4:	ee e6       	ldi	r30, 0x6E	; 110
 9e6:	f0 e0       	ldi	r31, 0x00	; 0
 9e8:	80 81       	ld	r24, Z
 9ea:	81 60       	ori	r24, 0x01	; 1
 9ec:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 9ee:	e1 e8       	ldi	r30, 0x81	; 129
 9f0:	f0 e0       	ldi	r31, 0x00	; 0
 9f2:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 9f4:	80 81       	ld	r24, Z
 9f6:	82 60       	ori	r24, 0x02	; 2
 9f8:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 9fa:	80 81       	ld	r24, Z
 9fc:	81 60       	ori	r24, 0x01	; 1
 9fe:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 a00:	e0 e8       	ldi	r30, 0x80	; 128
 a02:	f0 e0       	ldi	r31, 0x00	; 0
 a04:	80 81       	ld	r24, Z
 a06:	81 60       	ori	r24, 0x01	; 1
 a08:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 a0a:	e1 eb       	ldi	r30, 0xB1	; 177
 a0c:	f0 e0       	ldi	r31, 0x00	; 0
 a0e:	80 81       	ld	r24, Z
 a10:	84 60       	ori	r24, 0x04	; 4
 a12:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 a14:	e0 eb       	ldi	r30, 0xB0	; 176
 a16:	f0 e0       	ldi	r31, 0x00	; 0
 a18:	80 81       	ld	r24, Z
 a1a:	81 60       	ori	r24, 0x01	; 1
 a1c:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 a1e:	ea e7       	ldi	r30, 0x7A	; 122
 a20:	f0 e0       	ldi	r31, 0x00	; 0
 a22:	80 81       	ld	r24, Z
 a24:	84 60       	ori	r24, 0x04	; 4
 a26:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 a28:	80 81       	ld	r24, Z
 a2a:	82 60       	ori	r24, 0x02	; 2
 a2c:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 a2e:	80 81       	ld	r24, Z
 a30:	81 60       	ori	r24, 0x01	; 1
 a32:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 a34:	80 81       	ld	r24, Z
 a36:	80 68       	ori	r24, 0x80	; 128
 a38:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 a3a:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 a3e:	08 95       	ret

00000a40 <__udivmodsi4>:
 a40:	a1 e2       	ldi	r26, 0x21	; 33
 a42:	1a 2e       	mov	r1, r26
 a44:	aa 1b       	sub	r26, r26
 a46:	bb 1b       	sub	r27, r27
 a48:	fd 01       	movw	r30, r26
 a4a:	0d c0       	rjmp	.+26     	; 0xa66 <__udivmodsi4_ep>

00000a4c <__udivmodsi4_loop>:
 a4c:	aa 1f       	adc	r26, r26
 a4e:	bb 1f       	adc	r27, r27
 a50:	ee 1f       	adc	r30, r30
 a52:	ff 1f       	adc	r31, r31
 a54:	a2 17       	cp	r26, r18
 a56:	b3 07       	cpc	r27, r19
 a58:	e4 07       	cpc	r30, r20
 a5a:	f5 07       	cpc	r31, r21
 a5c:	20 f0       	brcs	.+8      	; 0xa66 <__udivmodsi4_ep>
 a5e:	a2 1b       	sub	r26, r18
 a60:	b3 0b       	sbc	r27, r19
 a62:	e4 0b       	sbc	r30, r20
 a64:	f5 0b       	sbc	r31, r21

00000a66 <__udivmodsi4_ep>:
 a66:	66 1f       	adc	r22, r22
 a68:	77 1f       	adc	r23, r23
 a6a:	88 1f       	adc	r24, r24
 a6c:	99 1f       	adc	r25, r25
 a6e:	1a 94       	dec	r1
 a70:	69 f7       	brne	.-38     	; 0xa4c <__udivmodsi4_loop>
 a72:	60 95       	com	r22
 a74:	70 95       	com	r23
 a76:	80 95       	com	r24
 a78:	90 95       	com	r25
 a7a:	9b 01       	movw	r18, r22
 a7c:	ac 01       	movw	r20, r24
 a7e:	bd 01       	movw	r22, r26
 a80:	cf 01       	movw	r24, r30
 a82:	08 95       	ret

00000a84 <__tablejump2__>:
 a84:	ee 0f       	add	r30, r30
 a86:	ff 1f       	adc	r31, r31
 a88:	05 90       	lpm	r0, Z+
 a8a:	f4 91       	lpm	r31, Z
 a8c:	e0 2d       	mov	r30, r0
 a8e:	09 94       	ijmp

00000a90 <_exit>:
 a90:	f8 94       	cli

00000a92 <__stop_program>:
 a92:	ff cf       	rjmp	.-2      	; 0xa92 <__stop_program>
